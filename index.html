<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8' />
  <meta http-equiv='X-UA-Compatible' content='IE=edge' />
  <meta name='viewport' content='width=device-width, initial-scale=1.0' />
  <title>RVTools Export Analyzer</title>
  <link rel='preconnect' href='https://fonts.googleapis.com' />
  <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin />
  <link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' rel='stylesheet' />
  <script src='https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js' integrity='sha384-z+evsV21KD2yg4KKmaOQZeqpdvFGFqH2BbRkTSaprPS0Bgdn4l2GcNw3nb+VHLa8' crossorigin='anonymous'></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --card-bg: rgba(15, 23, 42, 0.8);
      --card-border: rgba(148, 163, 184, 0.2);
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --success: #34d399;
      --warning: #fbbf24;
      --danger: #f87171;
      --shadow: 0 20px 40px rgba(15, 23, 42, 0.3);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at top left, #1e293b, #020617);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 0;
    }

    a {
      color: inherit;
    }

    header {
      padding: clamp(1.5rem, 5vw, 3rem) clamp(1.5rem, 5vw, 3rem) 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.75rem, 4vw, 2.75rem);
      font-weight: 700;
      letter-spacing: -0.02em;
      color: #f8fafc;
    }

    header p {
      margin: 0;
      max-width: 60ch;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 clamp(1.5rem, 5vw, 3rem) clamp(2rem, 5vw, 3.5rem);
    }

    .uploader {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      padding: clamp(1.5rem, 4vw, 2.5rem);
      display: grid;
      gap: 1.25rem;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .uploader::before {
      content: '';
      position: absolute;
      inset: -20% 30% 60% -30%;
      background: radial-gradient(circle, rgba(56, 189, 248, 0.25), transparent 70%);
      pointer-events: none;
    }
    .uploader label {
      font-weight: 600;
      font-size: 1.05rem;
    }

    .uploader .hint {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .file-input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }

    input[type='file'] {
      background: rgba(30, 41, 59, 0.8);
      border: 1px dashed rgba(148, 163, 184, 0.4);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      color: var(--text-secondary);
      cursor: pointer;
      max-width: 100%;
    }

    input[type='file']:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 3px;
    }

    button {
      background: linear-gradient(135deg, var(--accent-strong), var(--accent));
      color: #0f172a;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.4rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 10px 25px rgba(14, 165, 233, 0.25);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 30px rgba(14, 165, 233, 0.35);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.15);
      color: var(--text-secondary);
      box-shadow: none;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.75rem;
      background: rgba(148, 163, 184, 0.15);
      border-radius: 999px;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .summary-card {
      background: rgba(15, 23, 42, 0.7);
      border-radius: 16px;
      padding: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.18);
      display: grid;
      gap: 0.25rem;
      min-height: 120px;
      position: relative;
      overflow: hidden;
    }

    .summary-card::after {
      content: '';
      position: absolute;
      inset: auto -40% -40% auto;
      width: 140px;
      height: 140px;
      background: radial-gradient(circle, rgba(56, 189, 248, 0.18), transparent 70%);
      pointer-events: none;
      transform: rotate(25deg);
    }

    .summary-card span {
      font-size: 0.85rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .summary-card strong {
      font-size: 1.8rem;
      font-weight: 700;
    }

    .dashboard-grid {
      margin-top: 2.5rem;
      display: grid;
      gap: 1.5rem;
    }

    .dashboard-grid .row {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }

    .card {
      background: var(--card-bg);
      border-radius: 18px;
      padding: 1.5rem;
      border: 1px solid var(--card-border);
      box-shadow: var(--shadow);
      display: grid;
      gap: 1.25rem;
    }

    .card h2 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
    }
    .card h2 span {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .insight-list {
      margin: 0;
      padding-left: 1.1rem;
      color: var(--text-secondary);
      display: grid;
      gap: 0.4rem;
    }

    .insight-list li::marker {
      color: var(--accent);
    }

    .insight-list li strong {
      color: var(--text-primary);
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      min-height: 220px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .empty-state {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.95rem;
      padding: 1rem;
      opacity: 0.8;
    }

    .hidden {
      display: none !important;
    }

    .loading-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.65rem;
      color: var(--accent);
      font-weight: 500;
    }

    .loading-indicator::before {
      content: '';
      width: 18px;
      height: 18px;
      border: 3px solid rgba(56, 189, 248, 0.35);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .table-wrapper {
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      overflow: hidden;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      background: rgba(15, 23, 42, 0.35);
    }

    thead {
      background: rgba(56, 189, 248, 0.12);
      color: #e0f2fe;
    }

    th,
    td {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
      text-align: left;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      font-size: 0.75rem;
      text-transform: capitalize;
    }

    .pill.success {
      background: rgba(52, 211, 153, 0.15);
      color: var(--success);
    }

    .pill.warning {
      background: rgba(251, 191, 36, 0.18);
      color: var(--warning);
    }

    .pill.danger {
      background: rgba(248, 113, 113, 0.18);
      color: var(--danger);
    }

    .error-banner {
      background: rgba(248, 113, 113, 0.18);
      border: 1px solid rgba(248, 113, 113, 0.35);
      color: #fecaca;
      padding: 0.85rem 1rem;
      border-radius: 12px;
    }

    footer {
      margin-top: 3rem;
      padding: 1.5rem 0 2.5rem;
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    @media (max-width: 768px) {
      .card h2 {
        flex-direction: column;
        align-items: flex-start;
      }

      .file-input-group {
        flex-direction: column;
        align-items: flex-start;
      }

      header p {
        max-width: unset;
      }
    }
  </style>
</head>
<body>
  <div class='page'>
    <header>
      <span class='badge'>RVTools Analytics Workspace</span>
      <h1>RVTools Export Analyzer</h1>
      <p>Upload one or more RVTools exports (XLSX or CSV) to instantly explore availability, manageability, performance, recoverability, security, and cost indicators for your vSphere estate. Data never leaves your browser.</p>
    </header>

    <section class='uploader' aria-labelledby='uploader-label'>
      <div>
        <label id='uploader-label' for='fileInput'>Select RVTools export files</label>
        <p class='hint'>Supports multiple files. Drop the standard RVTools XLSX export or CSV outputs to blend results across environments.</p>
      </div>
      <div class='file-input-group'>
        <input id='fileInput' type='file' accept='.xlsx,.xls,.csv' multiple />
        <button type='button' id='resetButton' class='secondary'>Reset dashboard</button>
        <span id='loadingIndicator' class='loading-indicator hidden'>Crunching telemetry</span>
      </div>
      <div id='errorBanner' class='error-banner hidden' role='alert'></div>
      <div class='hint'>Processed files: <span id='fileList'>None</span></div>
    </section>

    <section class='summary-grid' aria-live='polite'>
      <article class='summary-card'>
        <span>Total files</span>
        <strong id='summary-files'>0</strong>
      </article>
      <article class='summary-card'>
        <span>Total VMs</span>
        <strong id='summary-vms'>0</strong>
      </article>
      <article class='summary-card'>
        <span>Powered on</span>
        <strong id='summary-powered-on'>0</strong>
      </article>
      <article class='summary-card'>
        <span>Powered off / suspended</span>
        <strong id='summary-powered-off'>0</strong>
      </article>
      <article class='summary-card'>
        <span>Avg CPU usage (%)</span>
        <strong id='summary-cpu'>0%</strong>
      </article>
      <article class='summary-card'>
        <span>Estimated monthly cost</span>
        <strong id='summary-cost'>$0</strong>
      </article>
    </section>

    <section class='dashboard-grid'>
      <div class='row'>
        <article class='card' id='availability-card'>
          <h2>
            Availability
            <span>Power state and host resiliency</span>
          </h2>
          <ul class='insight-list' id='availability-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='availabilityChart' aria-label='Availability distribution chart'></canvas>
            <p id='availabilityEmpty' class='empty-state hidden'>No power state data found.</p>
          </div>
        </article>
        <article class='card' id='manageability-card'>
          <h2>
            Manageability
            <span>VMware Tools and configuration drift</span>
          </h2>
          <ul class='insight-list' id='manageability-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='manageabilityChart' aria-label='Manageability status chart'></canvas>
            <p id='manageabilityEmpty' class='empty-state hidden'>No VMware Tools status detected.</p>
          </div>
        </article>
      </div>
      <div class='row'>
        <article class='card' id='performance-card'>
          <h2>
            Performance
            <span>Resource consumption signals</span>
          </h2>
          <ul class='insight-list' id='performance-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='performanceChart' aria-label='Performance summary chart'></canvas>
            <p id='performanceEmpty' class='empty-state hidden'>No CPU or memory utilization metrics detected.</p>
          </div>
          <div class='table-wrapper' id='performanceTableWrapper'>
            <table aria-label='Top virtual machines by performance metrics'>
              <thead>
                <tr>
                  <th scope='col'>VM</th>
                  <th scope='col'>CPU %</th>
                  <th scope='col'>CPU MHz</th>
                  <th scope='col'>Memory GB</th>
                </tr>
              </thead>
              <tbody id='performanceTableBody'></tbody>
            </table>
          </div>
        </article>
        <article class='card' id='recoverability-card'>
          <h2>
            Recoverability
            <span>Snapshot hygiene</span>
          </h2>
          <ul class='insight-list' id='recoverability-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='recoverabilityChart' aria-label='Snapshot age distribution chart'></canvas>
            <p id='recoverabilityEmpty' class='empty-state hidden'>No snapshot information supplied.</p>
          </div>
          <div class='table-wrapper' id='snapshotTableWrapper'>
            <table aria-label='Virtual machines with the oldest snapshots'>
              <thead>
                <tr>
                  <th scope='col'>VM</th>
                  <th scope='col'>Snapshots</th>
                  <th scope='col'>Oldest (days)</th>
                  <th scope='col'>Newest snapshot</th>
                </tr>
              </thead>
              <tbody id='snapshotTableBody'></tbody>
            </table>
          </div>
        </article>
      </div>
      <div class='row'>
        <article class='card' id='security-card'>
          <h2>
            Security
            <span>Hardware version & guest OS posture</span>
          </h2>
          <ul class='insight-list' id='security-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='securityChart' aria-label='Virtual hardware version chart'></canvas>
            <p id='securityEmpty' class='empty-state hidden'>No hardware version metadata detected.</p>
          </div>
        </article>
        <article class='card' id='cost-card'>
          <h2>
            Cost
            <span>Resource footprint estimates</span>
          </h2>
          <ul class='insight-list' id='cost-insights'></ul>
          <div class='chart-wrapper'>
            <canvas id='costChart' aria-label='Cost breakdown chart'></canvas>
            <p id='costEmpty' class='empty-state hidden'>No CPU, RAM, or storage capacity discovered.</p>
          </div>
        </article>
      </div>

      <article class='card' id='health-card'>
        <h2>
          Operational health signals
          <span>Findings from the vHealth worksheet</span>
        </h2>
        <div class='table-wrapper'>
          <table aria-label='Operational health findings from RVTools'>
            <thead>
              <tr>
                <th scope='col'>Category</th>
                <th scope='col'>Finding</th>
                <th scope='col'>VM / Object</th>
              </tr>
            </thead>
            <tbody id='healthTableBody'></tbody>
          </table>
        </div>
      </article>
    </section>
  </div>

  <footer>
    Built for rapid offline analysis of RVTools exports. No data is uploaded or stored.
  </footer>
  <script>
    const COST_RATES = {
      vcpu: 15,
      ramGB: 7,
      storageGB: 0.12,
    };

    const RVTOOLS_SHEET_HINTS = [
      'vinfo',
      'vhealth',
      'vsnapshot',
      'vdisk',
      'vmemory',
      'vcpu',
      'vpartition',
      'vhardware',
      'vnetwork',
      'vhost',
    ];

    const charts = {};

    const TEXT_DECODER = new TextDecoder('utf-8');
    const EXCEL_EPOCH_UTC = Date.UTC(1899, 11, 30);

    document.addEventListener('DOMContentLoaded', () => {
      const fileInput = document.getElementById('fileInput');
      const resetButton = document.getElementById('resetButton');

      fileInput.addEventListener('change', handleFileInput);
      resetButton.addEventListener('click', () => {
        fileInput.value = '';
        clearDashboard();
      });

      clearDashboard();
    });

    function showError(message) {
      const errorBanner = document.getElementById('errorBanner');
      if (!message) {
        errorBanner.classList.add('hidden');
        errorBanner.textContent = '';
        return;
      }
      errorBanner.textContent = message;
      errorBanner.classList.remove('hidden');
    }

    function toggleLoading(isLoading) {
      const indicator = document.getElementById('loadingIndicator');
      if (isLoading) {
        indicator.classList.remove('hidden');
      } else {
        indicator.classList.add('hidden');
      }
    }

    function clearDashboard(preserveError = false) {
      if (!preserveError) {
        showError('');
      }
      toggleLoading(false);

      const summaryDefaults = {
        'summary-files': '0',
        'summary-vms': '0',
        'summary-powered-on': '0',
        'summary-powered-off': '0',
        'summary-cpu': '0%',
        'summary-cost': '$0',
      };

      Object.entries(summaryDefaults).forEach(([id, value]) => {
        const el = document.getElementById(id);
        if (el) {
          el.textContent = value;
        }
      });

      document.getElementById('fileList').textContent = 'None';

      const lists = [
        'availability-insights',
        'manageability-insights',
        'performance-insights',
        'recoverability-insights',
        'security-insights',
        'cost-insights',
      ];

      lists.forEach((id) => {
        const list = document.getElementById(id);
        if (list) {
          list.innerHTML = '<li>No insights yet. Upload RVTools exports to begin.</li>';
        }
      });

      ['performanceTableBody', 'snapshotTableBody', 'healthTableBody'].forEach((id) => {
        const tbody = document.getElementById(id);
        if (tbody) {
          tbody.innerHTML = '';
        }
      });

      Object.values(charts).forEach((chart) => {
        if (chart) {
          chart.destroy();
        }
      });

      ['availabilityChart', 'manageabilityChart', 'performanceChart', 'recoverabilityChart', 'securityChart', 'costChart'].forEach((id) => {
        const canvas = document.getElementById(id);
        if (canvas) {
          const ctx = canvas.getContext('2d');
          if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
      });

      ['availabilityEmpty', 'manageabilityEmpty', 'performanceEmpty', 'recoverabilityEmpty', 'securityEmpty', 'costEmpty'].forEach((id) => {
        const el = document.getElementById(id);
        if (el) {
          el.classList.remove('hidden');
        }
      });
    }
    async function handleFileInput(event) {
      const files = Array.from(event.target.files || []);
      if (!files.length) {
        clearDashboard();
        return;
      }

      toggleLoading(true);
      showError('');

      try {
        const results = await Promise.allSettled(files.map(readWorkbook));
        const successful = [];
        const failures = [];

        results.forEach((result, index) => {
          const fileName = files[index].name;
          if (result.status === 'fulfilled') {
            const { workbook } = result.value;
            if (isLikelyRvtoolsWorkbook(workbook)) {
              successful.push(result.value);
            } else {
              failures.push(`${fileName}: no RVTools worksheets detected`);
            }
          } else {
            const reason = result.reason && result.reason.message ? result.reason.message : 'Unknown parsing error';
            failures.push(`${fileName}: ${reason}`);
          }
        });

        if (!successful.length) {
          clearDashboard(true);
          showError(`Unable to extract RVTools data. ${failures.join(' • ')}`.trim());
          return;
        }

        const analysis = analyseWorkbooks(successful);
        renderDashboard(analysis);

        const warnings = [...failures, ...((analysis.meta && analysis.meta.warnings) || [])];
        if (warnings.length) {
          const processedLabel = `Processed ${successful.length} file${successful.length === 1 ? '' : 's'} with warnings`;
          showError(`${processedLabel}: ${warnings.join(' • ')}`);
        } else {
          showError('');
        }
      } catch (error) {
        console.error(error);
        clearDashboard(true);
        showError('Unexpected error while analysing the selected files.');
      } finally {
        toggleLoading(false);
      }
    }

    function readWorkbook(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error(`Unable to read ${file.name}.`));
        reader.onload = async (event) => {
          try {
            const arrayBuffer = event.target.result;
            const workbook = await parseWorkbookBuffer(arrayBuffer, file);
            resolve({ fileName: file.name, workbook });
          } catch (err) {
            const reason = err && err.message ? err.message : 'Unknown error';
            reject(new Error(`Failed to parse ${file.name}: ${reason}`));
          }
        };
        reader.readAsArrayBuffer(file);
      });
    }

    async function parseWorkbookBuffer(arrayBuffer, file) {
      if (!(arrayBuffer instanceof ArrayBuffer)) {
        throw new Error('Unrecognised file payload.');
      }

      const name = file && file.name ? file.name.toLowerCase() : '';
      if (name.endsWith('.csv')) {
        return parseCsvWorkbook(arrayBuffer, file ? file.name : 'Worksheet');
      }
      if (name.endsWith('.xls')) {
        throw new Error('Legacy XLS files are not supported. Export as XLSX/CSV and retry.');
      }

      return parseXlsxWorkbook(arrayBuffer);
    }

    function parseCsvWorkbook(arrayBuffer, fileName) {
      const text = TEXT_DECODER.decode(arrayBuffer);
      const sanitized = text.replace(/^\uFEFF/, '');
      const parsed = parseCsv(sanitized);
      const sheetName = deriveSheetName(fileName);
      return {
        sheetNames: [sheetName],
        sheets: { [sheetName]: parsed.rows },
        warnings: parsed.warnings || [],
      };
    }

    function parseCsv(text) {
      const rows = [];
      let current = '';
      let inQuotes = false;
      let currentRow = [];

      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];

        if (inQuotes) {
          if (char === '"') {
            if (text[i + 1] === '"') {
              current += '"';
              i += 1;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
          continue;
        }

        if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          currentRow.push(current);
          current = '';
        } else if (char === '\n') {
          currentRow.push(current);
          rows.push(currentRow);
          currentRow = [];
          current = '';
        } else if (char === '\r') {
          if (text[i + 1] !== '\n') {
            currentRow.push(current);
            rows.push(currentRow);
            currentRow = [];
            current = '';
          }
        } else {
          current += char;
        }
      }

      if (inQuotes) {
        currentRow.push(current);
        rows.push(currentRow);
      } else if (current !== '' || currentRow.length) {
        currentRow.push(current);
        rows.push(currentRow);
      }

      if (!rows.length) {
        return { headers: [], rows: [] };
      }

      const headerCells = rows.shift() || [];
      const headers = headerCells.map((cell, index) => {
        const label = typeof cell === 'string' ? cell.trim() : String(cell || '').trim();
        return label || `Column ${index + 1}`;
      });

      const data = [];
      rows.forEach((cells) => {
        const entry = {};
        let nonEmpty = false;
        const maxColumns = Math.max(headers.length, cells.length);
        for (let i = 0; i < maxColumns; i += 1) {
          if (!headers[i]) {
            headers[i] = `Column ${i + 1}`;
          }
          const rawValue = cells[i] !== undefined ? cells[i] : '';
          const value = typeof rawValue === 'string' ? rawValue.trim() : rawValue;
          if (value !== null && value !== undefined && value !== '') {
            nonEmpty = true;
          }
          entry[headers[i]] = value;
        }
        if (nonEmpty) {
          data.push(entry);
        }
      });

      return { headers, rows: data };
    }

    function deriveSheetName(fileName) {
      if (!fileName) return 'Sheet1';
      const trimmed = fileName.trim();
      const withoutExt = trimmed.replace(/\.[^.]+$/, '');
      return withoutExt || 'Sheet1';
    }

    async function parseXlsxWorkbook(arrayBuffer) {
      const entries = await unzipXlsx(arrayBuffer);
      const workbookXmlBytes = entries['xl/workbook.xml'];
      if (!workbookXmlBytes) {
        throw new Error('Workbook metadata (xl/workbook.xml) is missing.');
      }

      const workbookXml = TEXT_DECODER.decode(workbookXmlBytes);
      const relationshipsXmlBytes = entries['xl/_rels/workbook.xml.rels'];
      const relationshipsXml = relationshipsXmlBytes ? TEXT_DECODER.decode(relationshipsXmlBytes) : null;
      const sharedStringsBytes = entries['xl/sharedStrings.xml'];
      const sharedStringsXml = sharedStringsBytes ? TEXT_DECODER.decode(sharedStringsBytes) : null;
      const sharedStrings = sharedStringsXml ? parseSharedStrings(sharedStringsXml) : [];

      const warnings = [];
      let definitions = parseWorkbookDefinition(workbookXml, relationshipsXml);
      if (!definitions.length) {
        const fallbackTargets = Object.keys(entries).filter((key) =>
          /^xl\/worksheets\/[^/]+\.xml$/i.test(key)
        );

        if (fallbackTargets.length) {
          warnings.push(
            'Workbook metadata did not reference any worksheets. Falling back to detected worksheet files.'
          );
          definitions = fallbackTargets.map((path, index) => ({
            name: deriveSheetName(path.split('/').pop() || `Sheet ${index + 1}`) || `Sheet ${index + 1}`,
            path,
          }));
        } else {
          throw new Error('No worksheets found within the workbook.');
        }
      }

      const sheets = {};
      const sheetNames = [];

      definitions.forEach((definition) => {
        const sheetName = definition.name || `Sheet ${sheetNames.length + 1}`;
        const targetPath = definition.path;
        sheetNames.push(sheetName);

        if (!targetPath) {
          warnings.push(`Sheet "${sheetName}" is missing a relationship target.`);
          sheets[sheetName] = [];
          return;
        }

        const sheetBytes = entries[targetPath];
        if (!sheetBytes) {
          warnings.push(`Sheet "${sheetName}" could not be located in the workbook archive.`);
          sheets[sheetName] = [];
          return;
        }

        const sheetXml = TEXT_DECODER.decode(sheetBytes);
        try {
          const parsedSheet = parseWorksheet(sheetXml, sharedStrings);
          sheets[sheetName] = parsedSheet.rows;
        } catch (sheetError) {
          const reason = sheetError && sheetError.message ? sheetError.message : 'unexpected format';
          warnings.push(`Sheet "${sheetName}" could not be parsed: ${reason}`);
          sheets[sheetName] = [];
        }
      });

      return { sheetNames, sheets, warnings };
    }

    async function unzipXlsx(arrayBuffer) {
      const view = new DataView(arrayBuffer);
      const bytes = new Uint8Array(arrayBuffer);
      const eocdOffset = findEndOfCentralDirectory(view);
      if (eocdOffset < 0) {
        throw new Error('The selected file is not a valid XLSX archive (no end of central directory).');
      }

      const totalEntries = view.getUint16(eocdOffset + 10, true);
      const centralDirectorySize = view.getUint32(eocdOffset + 12, true);
      const centralDirectoryOffset = view.getUint32(eocdOffset + 16, true);
      const entries = {};

      let cursor = centralDirectoryOffset;
      const centralDirectoryEnd = centralDirectoryOffset + centralDirectorySize;

      for (let index = 0; index < totalEntries && cursor < centralDirectoryEnd; index += 1) {
        const signature = view.getUint32(cursor, true);
        if (signature !== 0x02014b50) {
          break;
        }

        const compression = view.getUint16(cursor + 10, true);
        const compressedSize = view.getUint32(cursor + 20, true);
        const uncompressedSize = view.getUint32(cursor + 24, true);
        const fileNameLength = view.getUint16(cursor + 28, true);
        const extraLength = view.getUint16(cursor + 30, true);
        const commentLength = view.getUint16(cursor + 32, true);
        const localHeaderOffset = view.getUint32(cursor + 42, true);

        const nameStart = cursor + 46;
        const nameEnd = nameStart + fileNameLength;
        const fileNameBytes = bytes.slice(nameStart, nameEnd);
        const fileName = TEXT_DECODER.decode(fileNameBytes);

        cursor = nameEnd + extraLength + commentLength;

        const entry = {
          fileName,
          compression,
          compressedSize,
          uncompressedSize,
          localHeaderOffset,
        };

        entries[fileName] = await readZipEntry(entry, view, bytes);
      }

      return entries;
    }

    function findEndOfCentralDirectory(view) {
      for (let offset = view.byteLength - 22; offset >= 0; offset -= 1) {
        if (view.getUint32(offset, true) === 0x06054b50) {
          return offset;
        }
      }
      return -1;
    }

    async function readZipEntry(entry, view, bytes) {
      const offset = entry.localHeaderOffset;
      if (view.getUint32(offset, true) !== 0x04034b50) {
        throw new Error(`Invalid ZIP entry header for ${entry.fileName || 'unknown file'}.`);
      }

      const nameLength = view.getUint16(offset + 26, true);
      const extraLength = view.getUint16(offset + 28, true);
      const dataOffset = offset + 30 + nameLength + extraLength;
      const compressedSize = entry.compressedSize || view.getUint32(offset + 18, true);
      const compressed = bytes.slice(dataOffset, dataOffset + compressedSize);

      if (entry.compression === 0) {
        return compressed;
      }
      if (entry.compression === 8) {
        return inflateRaw(compressed);
      }

      throw new Error(`Unsupported compression method (${entry.compression}) for ${entry.fileName}.`);
    }

    async function inflateRaw(data) {
      if (typeof DecompressionStream === 'function') {
        const stream = new Blob([data]).stream().pipeThrough(new DecompressionStream('deflate-raw'));
        const buffer = await new Response(stream).arrayBuffer();
        return new Uint8Array(buffer);
      }

      throw new Error('Deflate decompression is not supported in this browser. Use a modern Chromium, Edge, or Safari release.');
    }

    function parseWorkbookDefinition(workbookXml, relationshipsXml) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(workbookXml, 'application/xml');
      if (doc.getElementsByTagName('parsererror').length) {
        throw new Error('Workbook metadata is malformed.');
      }

      const sheets = Array.from(doc.getElementsByTagName('sheet'));
      const relationships = parseRelationships(relationshipsXml);

      return sheets.map((sheet, index) => {
        const name = sheet.getAttribute('name') || `Sheet ${index + 1}`;
        const relId =
          sheet.getAttribute('r:id') ||
          sheet.getAttributeNS('http://schemas.openxmlformats.org/officeDocument/2006/relationships', 'id') ||
          sheet.getAttribute('id');
        let target = relId && relationships[relId] ? relationships[relId] : null;
        if (!target) {
          const sheetId = sheet.getAttribute('sheetId');
          if (sheetId) {
            target = `worksheets/sheet${sheetId}.xml`;
          }
        }
        return {
          name,
          path: target ? resolveWorkbookPath(target) : null,
        };
      });
    }

    function parseRelationships(relationshipsXml) {
      if (!relationshipsXml) return {};
      const parser = new DOMParser();
      const doc = parser.parseFromString(relationshipsXml, 'application/xml');
      if (doc.getElementsByTagName('parsererror').length) {
        return {};
      }

      const relationships = {};
      const nodes = doc.getElementsByTagName('Relationship');
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        const id = node.getAttribute('Id');
        const target = node.getAttribute('Target');
        if (id && target) {
          relationships[id] = target;
        }
      }
      return relationships;
    }

    function resolveWorkbookPath(target) {
      let normalized = target.replace(/\\/g, '/');
      normalized = normalized.replace(/^\//, '');
      normalized = normalized.replace(/^\.\//, '');
      while (normalized.startsWith('../')) {
        normalized = normalized.slice(3);
      }
      if (!normalized.startsWith('xl/')) {
        normalized = `xl/${normalized}`;
      }
      return normalized;
    }

    function parseSharedStrings(sharedStringsXml) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(sharedStringsXml, 'application/xml');
      if (doc.getElementsByTagName('parsererror').length) {
        return [];
      }

      const items = doc.getElementsByTagName('si');
      const strings = [];
      for (let i = 0; i < items.length; i += 1) {
        strings.push(collectText(items[i]));
      }
      return strings;
    }

    function parseWorksheet(xml, sharedStrings) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'application/xml');
      if (doc.getElementsByTagName('parsererror').length) {
        throw new Error('Worksheet XML is malformed.');
      }

      const rowNodes = Array.from(doc.getElementsByTagName('row'));
      if (!rowNodes.length) {
        return { headers: [], rows: [] };
      }

      let headers = null;
      const rows = [];

      rowNodes.forEach((rowNode) => {
        const cellNodes = Array.from(rowNode.getElementsByTagName('c'));
        if (!cellNodes.length && headers) {
          return;
        }

        const rowValues = [];
        let lastIndex = -1;

        cellNodes.forEach((cell) => {
          const reference = cell.getAttribute('r');
          let columnIndex = lastIndex + 1;
          if (reference) {
            const match = reference.match(/[A-Za-z]+/);
            if (match && match[0]) {
              columnIndex = columnLettersToIndex(match[0]);
            }
          }
          rowValues[columnIndex] = extractCellValue(cell, sharedStrings);
          lastIndex = columnIndex;
        });

        if (!headers) {
          headers = [];
          for (let i = 0; i < rowValues.length; i += 1) {
            const rawHeader = rowValues[i];
            const label = rawHeader !== null && rawHeader !== undefined ? String(rawHeader).trim() : '';
            headers[i] = label || `Column ${i + 1}`;
          }
          return;
        }

        if (headers.length < rowValues.length) {
          for (let i = headers.length; i < rowValues.length; i += 1) {
            headers[i] = `Column ${i + 1}`;
          }
        }

        const entry = {};
        let nonEmpty = false;
        for (let i = 0; i < headers.length; i += 1) {
          const header = headers[i] || `Column ${i + 1}`;
          const value = rowValues[i] !== undefined ? rowValues[i] : null;
          if (value !== null && value !== undefined && value !== '') {
            nonEmpty = true;
          }
          entry[header] = value;
        }

        if (nonEmpty) {
          rows.push(entry);
        }
      });

      return { headers: headers || [], rows };
    }

    function columnLettersToIndex(letters) {
      let index = 0;
      const normalized = letters.toUpperCase();
      for (let i = 0; i < normalized.length; i += 1) {
        index = index * 26 + (normalized.charCodeAt(i) - 64);
      }
      return index - 1;
    }

    function extractCellValue(cell, sharedStrings) {
      const type = cell.getAttribute('t');
      if (type === 'inlineStr') {
        const inlineNode = cell.getElementsByTagName('is')[0];
        return collectText(inlineNode || cell);
      }

      const valueNode = cell.getElementsByTagName('v')[0];
      const raw = valueNode ? valueNode.textContent || '' : '';

      if (type === 's') {
        const index = parseInt(raw, 10);
        if (Number.isInteger(index) && sharedStrings && sharedStrings[index] !== undefined) {
          return sharedStrings[index];
        }
        return '';
      }

      if (type === 'b') {
        const lowered = raw.toLowerCase();
        return lowered === '1' || lowered === 'true';
      }

      if (type === 'str') {
        return raw;
      }

      if (type === 'd') {
        const asDate = new Date(raw);
        return Number.isNaN(asDate.getTime()) ? raw : asDate;
      }

      if (!raw) {
        return '';
      }

      const numeric = Number(raw);
      if (!Number.isNaN(numeric)) {
        return numeric;
      }

      return raw;
    }

    function collectText(node) {
      if (!node || !node.childNodes) return '';
      let result = '';
      for (let i = 0; i < node.childNodes.length; i += 1) {
        const child = node.childNodes[i];
        if (child.nodeType === 3 || child.nodeType === 4) {
          result += child.nodeValue;
        } else if (child.nodeType === 1) {
          result += collectText(child);
        }
      }
      return result;
    }

    function isLikelyRvtoolsWorkbook(workbook) {
      if (!workbook) return false;
      const sheetNames = Array.isArray(workbook.sheetNames)
        ? workbook.sheetNames
        : Array.isArray(workbook.SheetNames)
        ? workbook.SheetNames
        : [];
      if (!sheetNames.length) return false;
      return sheetNames.some((sheetName) => {
        const name = sheetName ? sheetName.toString().toLowerCase() : '';
        return RVTOOLS_SHEET_HINTS.some((hint) => name.startsWith(hint));
      });
    }

    function analyseWorkbooks(workbooks) {
      const vmRecords = {};
      const healthFindings = [];

      const base = {
        meta: {
          files: workbooks.map((wb) => wb.fileName),
          totalVMs: 0,
          warnings: [],
        },
        availability: {
          powerStates: {},
        },
        manageability: {
          toolsStatus: {},
        },
        performance: {
          cpuPercentSum: 0,
          cpuPercentSamples: 0,
          cpuMhzSum: 0,
          cpuMhzSamples: 0,
          memoryUsageSumGB: 0,
          memoryUsageSamples: 0,
          memoryProvisionedSumGB: 0,
          storageUsedSumGB: 0,
        },
        recoverability: {
          totalSnapshots: 0,
          distribution: { lt7: 0, lt30: 0, gte30: 0 },
          oldestSnapshot: null,
          snapshotDetails: [],
        },
        security: {
          hardwareVersions: {},
          guestOS: {},
          flaggedVMs: [],
        },
        cost: {
          totalvCPU: 0,
          totalMemoryGB: 0,
          totalStorageGB: 0,
          breakdown: { cpu: 0, ram: 0, storage: 0 },
          estimatedMonthly: 0,
        },
        insights: {
          availability: [],
          manageability: [],
          performance: [],
          recoverability: [],
          security: [],
          cost: [],
        },
      };

      workbooks.forEach(({ fileName, workbook }) => {
        if (Array.isArray(workbook.warnings)) {
          workbook.warnings.forEach((warning) => {
            base.meta.warnings.push(`${fileName}: ${warning}`);
          });
        }

        const sheetNames = Array.isArray(workbook.sheetNames)
          ? workbook.sheetNames
          : Array.isArray(workbook.SheetNames)
          ? workbook.SheetNames
          : [];

        sheetNames.forEach((sheetName) => {
          const rowsSource =
            (workbook.sheets && workbook.sheets[sheetName]) ||
            (workbook.Sheets && workbook.Sheets[sheetName]) ||
            [];

          const rows = Array.isArray(rowsSource)
            ? rowsSource
            : rowsSource && Array.isArray(rowsSource.rows)
            ? rowsSource.rows
            : [];

          if (!rows.length) {
            return;
          }

          rows.forEach((row) => {
            try {
              processRow({
                row,
                sheetName,
                source: fileName,
                vmRecords,
                healthFindings,
              });
            } catch (rowError) {
              const reason = rowError && rowError.message ? rowError.message : 'unexpected format';
              base.meta.warnings.push(`Skipped a record in "${sheetName}" (${fileName}): ${reason}`);
            }
          });
        });
      });

      const vmList = Object.values(vmRecords);
      base.meta.totalVMs = vmList.length;

      vmList.forEach((vm) => {
        if (vm.powerState) {
          const normalized = normalizePowerState(vm.powerState);
          base.availability.powerStates[normalized] = (base.availability.powerStates[normalized] || 0) + 1;
        }

        if (vm.toolsStatus) {
          const normalized = normalizeToolsStatus(vm.toolsStatus);
          base.manageability.toolsStatus[normalized] = (base.manageability.toolsStatus[normalized] || 0) + 1;
        }

        if (isFinite(vm.cpuUsagePercent)) {
          base.performance.cpuPercentSum += vm.cpuUsagePercent;
          base.performance.cpuPercentSamples += 1;
        }

        if (isFinite(vm.cpuUsageMhz)) {
          base.performance.cpuMhzSum += vm.cpuUsageMhz;
          base.performance.cpuMhzSamples += 1;
        }

        if (isFinite(vm.memoryUsageGB)) {
          base.performance.memoryUsageSumGB += vm.memoryUsageGB;
          base.performance.memoryUsageSamples += 1;
        }

        if (isFinite(vm.memoryProvisionedGB)) {
          base.performance.memoryProvisionedSumGB += vm.memoryProvisionedGB;
        }

        if (isFinite(vm.storageUsedGB)) {
          base.performance.storageUsedSumGB += vm.storageUsedGB;
        }

        if (Array.isArray(vm.snapshots) && vm.snapshots.length) {
          base.recoverability.totalSnapshots += vm.snapshots.length;
          const sorted = vm.snapshots
            .map((snapshot) => ({
              name: snapshot.name,
              ageDays: deriveSnapshotAge(snapshot),
              created: snapshot.created,
            }))
            .filter((item) => isFinite(item.ageDays));

          if (sorted.length) {
            const oldest = sorted.reduce((max, current) => (current.ageDays > max.ageDays ? current : max), sorted[0]);
            if (!base.recoverability.oldestSnapshot || oldest.ageDays > base.recoverability.oldestSnapshot.ageDays) {
              base.recoverability.oldestSnapshot = {
                vm: vm.name,
                ...oldest,
              };
            }

            sorted.forEach((snapshot) => {
              if (snapshot.ageDays < 7) base.recoverability.distribution.lt7 += 1;
              else if (snapshot.ageDays < 30) base.recoverability.distribution.lt30 += 1;
              else base.recoverability.distribution.gte30 += 1;
            });

            base.recoverability.snapshotDetails.push({
              vm: vm.name,
              count: vm.snapshots.length,
              oldest: Math.max(...sorted.map((s) => s.ageDays)),
              newest: sorted.reduce((min, s) => (s.created && (!min || s.created > min) ? s.created : min), null),
            });
          }
        }

        if (vm.hardwareVersion) {
          const versionLabel = vm.hardwareVersion.toString().trim();
          base.security.hardwareVersions[versionLabel] = (base.security.hardwareVersions[versionLabel] || 0) + 1;
          const versionNumber = extractVersionNumber(versionLabel);
          if (versionNumber && versionNumber < 13) {
            base.security.flaggedVMs.push(`${vm.name} (HW v${versionNumber})`);
          }
        }

        if (vm.guestOS) {
          const label = vm.guestOS.toString().trim();
          base.security.guestOS[label] = (base.security.guestOS[label] || 0) + 1;
        }

        if (isFinite(vm.vcpu)) {
          base.cost.totalvCPU += vm.vcpu;
        }

        if (isFinite(vm.memoryProvisionedGB)) {
          base.cost.totalMemoryGB += vm.memoryProvisionedGB;
        }

        if (isFinite(vm.storageProvisionedGB)) {
          base.cost.totalStorageGB += vm.storageProvisionedGB;
        }
      });

      base.cost.breakdown.cpu = base.cost.totalvCPU * COST_RATES.vcpu;
      base.cost.breakdown.ram = base.cost.totalMemoryGB * COST_RATES.ramGB;
      base.cost.breakdown.storage = base.cost.totalStorageGB * COST_RATES.storageGB;
      base.cost.estimatedMonthly = base.cost.breakdown.cpu + base.cost.breakdown.ram + base.cost.breakdown.storage;

      base.insights = buildInsights({ base, vmList, healthFindings });

      base.performance.topVMs = computeTopVms(vmList);
      base.recoverability.snapshotDetails.sort((a, b) => (b.oldest || 0) - (a.oldest || 0));
      base.healthFindings = healthFindings;

      return base;
    }
    function processRow({ row, sheetName, source, vmRecords, healthFindings }) {
      const lowerSheet = (sheetName || '').toLowerCase();
      const vmField = findField(row, ['vm name', 'virtual machine', 'vm']);
      const vmName = vmField ? String(vmField.value).trim() : null;
      let vmRecord = null;

      if (vmName) {
        vmRecord = vmRecords[vmName] || { name: vmName, sources: new Set() };
        vmRecord.sources.add(source);
        vmRecords[vmName] = vmRecord;
      }

      if (lowerSheet.includes('health')) {
        const categoryField = findField(row, ['category']);
        const findingField = findField(row, ['message', 'finding', 'issue']);
        const objectField = vmField || findField(row, ['object', 'target']);
        if (categoryField || findingField) {
          healthFindings.push({
            category: categoryField ? String(categoryField.value) : 'General',
            finding: findingField ? String(findingField.value) : 'Finding',
            object: objectField ? String(objectField.value) : '',
          });
        }
      }

      if (!vmRecord) {
        return;
      }

      const powerState = findField(row, ['powerstate', 'power state', 'runtime power state']);
      if (powerState) {
        vmRecord.powerState = powerState.value;
      }

      const toolsStatus = findField(row, ['tools status', 'vmware tools status', 'vmware tools version status']);
      if (toolsStatus) {
        vmRecord.toolsStatus = toolsStatus.value;
      }

      const hardwareVersion = findField(row, ['hardware version', 'vm version']);
      if (hardwareVersion) {
        vmRecord.hardwareVersion = hardwareVersion.value;
      }

      const guestOS = findField(row, ['guest os']);
      if (guestOS) {
        vmRecord.guestOS = guestOS.value;
      }

      const cpuCount = findField(row, ['num cpu', 'numcpu', '# cpu', 'number of cpu', 'vcpu', 'cpus']);
      if (cpuCount) {
        const num = toNumber(cpuCount.value);
        if (isFinite(num)) {
          vmRecord.vcpu = Math.max(num, vmRecord.vcpu || 0);
        }
      }

      const cpuUsagePercent = findField(row, ['cpu usage %', 'cpu %', 'cpu usage percent']);
      if (cpuUsagePercent) {
        const num = toNumber(cpuUsagePercent.value);
        if (isFinite(num)) {
          vmRecord.cpuUsagePercent = Math.max(num, vmRecord.cpuUsagePercent || 0);
        }
      }

      const cpuUsageMhz = findField(row, ['cpu usage mhz', 'cpu mhz']);
      if (cpuUsageMhz) {
        const num = toNumber(cpuUsageMhz.value);
        if (isFinite(num)) {
          vmRecord.cpuUsageMhz = Math.max(num, vmRecord.cpuUsageMhz || 0);
        }
      }

      const cpuReady = findField(row, ['cpu ready', 'ready %']);
      if (cpuReady) {
        const num = toNumber(cpuReady.value);
        if (isFinite(num)) {
          vmRecord.cpuReadyPercent = Math.max(num, vmRecord.cpuReadyPercent || 0);
        }
      }

      if (lowerSheet.includes('disk') || lowerSheet.includes('vmdk')) {
        const diskProvisioned = findField(row, ['provisioned', 'capacity', 'size']);
        if (diskProvisioned) {
          const gb = convertToGB(diskProvisioned.value, diskProvisioned.key);
          if (isFinite(gb)) {
            vmRecord.storageProvisionedGB = (vmRecord.storageProvisionedGB || 0) + gb;
          }
        }
        const diskUsed = findField(row, ['used', 'in use']);
        if (diskUsed) {
          const gb = convertToGB(diskUsed.value, diskUsed.key);
          if (isFinite(gb)) {
            vmRecord.storageUsedGB = (vmRecord.storageUsedGB || 0) + gb;
          }
        }
      } else {
        const storageProvisioned = findField(row, ['provisioned', 'allocated storage', 'storage provisioned']);
        if (storageProvisioned) {
          const gb = convertToGB(storageProvisioned.value, storageProvisioned.key);
          if (isFinite(gb)) {
            vmRecord.storageProvisionedGB = Math.max(gb, vmRecord.storageProvisionedGB || 0);
          }
        }
        const storageUsed = findField(row, ['in use', 'used storage']);
        if (storageUsed) {
          const gb = convertToGB(storageUsed.value, storageUsed.key);
          if (isFinite(gb)) {
            vmRecord.storageUsedGB = Math.max(gb, vmRecord.storageUsedGB || 0);
          }
        }
      }

      const memoryProvisioned = findField(row, ['provisioned mib', 'memory size', 'config memory', 'memory mb', 'memory gb']);
      if (memoryProvisioned) {
        const gb = convertToGB(memoryProvisioned.value, memoryProvisioned.key);
        if (isFinite(gb)) {
          vmRecord.memoryProvisionedGB = Math.max(gb, vmRecord.memoryProvisionedGB || 0);
        }
      }

      const memoryUsage = findField(row, ['in use mib', 'memory usage', 'active memory', 'consumed memory']);
      if (memoryUsage) {
        const gb = convertToGB(memoryUsage.value, memoryUsage.key);
        if (isFinite(gb)) {
          vmRecord.memoryUsageGB = Math.max(gb, vmRecord.memoryUsageGB || 0);
        }
      }

      if (lowerSheet.includes('snapshot')) {
        const snapshotName = findField(row, ['snapshot name', 'name']);
        const snapshotAge = findField(row, ['age', 'age (days)']);
        const snapshotCreated = findField(row, ['create time', 'created']);
        if (!vmRecord.snapshots) vmRecord.snapshots = [];
        if (snapshotName || snapshotAge || snapshotCreated) {
          vmRecord.snapshots.push({
            name: snapshotName ? snapshotName.value : 'Snapshot',
            age: snapshotAge ? toNumber(snapshotAge.value) : null,
            created: snapshotCreated ? toDate(snapshotCreated.value) : null,
          });
        }
      } else {
        const snapshotCount = findField(row, ['number of snapshots', '# snapshots', 'snapshot count']);
        if (snapshotCount) {
          const count = toNumber(snapshotCount.value);
          if (isFinite(count) && count > 0 && !vmRecord.snapshots) {
            vmRecord.snapshots = Array.from({ length: Math.round(count) }, () => ({
              name: 'Snapshot',
              age: null,
              created: null,
            }));
          }
        }
      }
    }
    function findField(row, patterns) {
      if (!row || typeof row !== 'object') return null;
      const keys = Object.keys(row);
      for (const key of keys) {
        const normalized = key.toLowerCase();
        if (patterns.some((pattern) => normalized.includes(pattern))) {
          const value = row[key];
          if (value !== null && value !== undefined && value !== '') {
            return { key, value };
          }
        }
      }
      return null;
    }

    function normalizePowerState(state) {
      if (!state) return 'Unknown';
      const normalized = state.toString().trim().toLowerCase();
      if (normalized.includes('on')) return 'Powered on';
      if (normalized.includes('suspend')) return 'Suspended';
      if (normalized.includes('off')) return 'Powered off';
      if (normalized.includes('unknown')) return 'Unknown';
      return state.toString().trim();
    }

    function normalizeToolsStatus(status) {
      if (!status) return 'Unknown';
      const normalized = status.toString().trim().toLowerCase();
      if (normalized.includes('not installed')) return 'Not installed';
      if (normalized.includes('not running')) return 'Not running';
      if (normalized.includes('current') || normalized.includes('ok') || normalized.includes('running')) return 'Up to date';
      if (normalized.includes('out of date') || normalized.includes('old') || normalized.includes('upgrade')) return 'Out of date';
      return status.toString().trim();
    }

    function toNumber(value) {
      if (value === null || value === undefined || value === '') return NaN;
      if (typeof value === 'number') return value;
      const cleaned = value.toString().replace(/[^0-9.+-]/g, '');
      const parsed = parseFloat(cleaned);
      return Number.isFinite(parsed) ? parsed : NaN;
    }

    function toDate(value) {
      if (value === null || value === undefined || value === '') return null;
      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value;
      }
      if (typeof value === 'number' && Number.isFinite(value)) {
        if (value > 25569 && value < 600000) {
          return excelSerialToDate(value);
        }
        const numericDate = new Date(value);
        return Number.isNaN(numericDate.getTime()) ? null : numericDate;
      }
      const parsed = new Date(value);
      return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function excelSerialToDate(serial) {
      const adjusted = serial > 59 ? serial - 1 : serial;
      const millis = adjusted * 24 * 60 * 60 * 1000;
      return new Date(EXCEL_EPOCH_UTC + millis);
    }

    function convertToGB(value, key) {
      const numeric = toNumber(value);
      if (!Number.isFinite(numeric)) return NaN;
      const lowerKey = (key || '').toLowerCase();
      if (lowerKey.includes('tb')) return numeric * 1024;
      if (lowerKey.includes('gb')) return numeric;
      if (lowerKey.includes('mib') || lowerKey.includes('mb')) return numeric / 1024;
      if (lowerKey.includes('kb') || lowerKey.includes('kib')) return numeric / (1024 * 1024);
      return numeric / 1024;
    }

    function deriveSnapshotAge(snapshot) {
      if (!snapshot) return NaN;
      if (Number.isFinite(snapshot.age)) return snapshot.age;
      if (snapshot.created) {
        const now = new Date();
        const diff = now - snapshot.created;
        return diff > 0 ? diff / (1000 * 60 * 60 * 24) : NaN;
      }
      return NaN;
    }

    function extractVersionNumber(label) {
      if (!label) return null;
      const match = label.toString().match(/(\d+)/);
      return match ? parseInt(match[1], 10) : null;
    }
    function computeTopVms(vmList) {
      const byCpuPercent = vmList
        .filter((vm) => isFinite(vm.cpuUsagePercent))
        .sort((a, b) => b.cpuUsagePercent - a.cpuUsagePercent)
        .slice(0, 6);

      const byCpuMhz = vmList
        .filter((vm) => isFinite(vm.cpuUsageMhz))
        .sort((a, b) => b.cpuUsageMhz - a.cpuUsageMhz)
        .slice(0, 6);

      const byMemory = vmList
        .filter((vm) => isFinite(vm.memoryUsageGB))
        .sort((a, b) => b.memoryUsageGB - a.memoryUsageGB)
        .slice(0, 6);

      const merged = new Map();
      [...byCpuPercent, ...byCpuMhz, ...byMemory].forEach((vm) => {
        if (!merged.has(vm.name)) {
          merged.set(vm.name, {
            name: vm.name,
            cpuPercent: isFinite(vm.cpuUsagePercent) ? vm.cpuUsagePercent : null,
            cpuMhz: isFinite(vm.cpuUsageMhz) ? vm.cpuUsageMhz : null,
            memoryGB: isFinite(vm.memoryUsageGB) ? vm.memoryUsageGB : null,
          });
        } else {
          const existing = merged.get(vm.name);
          if (!isFinite(existing.cpuPercent) && isFinite(vm.cpuUsagePercent)) existing.cpuPercent = vm.cpuUsagePercent;
          if (!isFinite(existing.cpuMhz) && isFinite(vm.cpuUsageMhz)) existing.cpuMhz = vm.cpuUsageMhz;
          if (!isFinite(existing.memoryGB) && isFinite(vm.memoryUsageGB)) existing.memoryGB = vm.memoryUsageGB;
        }
      });

      return Array.from(merged.values())
        .sort((a, b) => (b.cpuPercent || 0) - (a.cpuPercent || 0) || (b.cpuMhz || 0) - (a.cpuMhz || 0))
        .slice(0, 8);
    }

    function buildInsights({ base, vmList, healthFindings }) {
      const insights = {
        availability: [],
        manageability: [],
        performance: [],
        recoverability: [],
        security: [],
        cost: [],
      };

      const totalPowerStates = Object.values(base.availability.powerStates).reduce((acc, value) => acc + value, 0);
      const poweredOn = base.availability.powerStates['Powered on'] || 0;
      const poweredOff = (base.availability.powerStates['Powered off'] || 0) + (base.availability.powerStates['Suspended'] || 0);

      if (totalPowerStates) {
        const availabilityPercent = poweredOn / totalPowerStates;
        insights.availability.push(`${poweredOn} of ${totalPowerStates} VMs are powered on (${formatPercent(availabilityPercent)} availability).`);
      } else {
        insights.availability.push('Power state information unavailable.');
      }

      if (poweredOff) {
        insights.availability.push(`${poweredOff} VMs are currently powered off or suspended. Validate intentional downtime.`);
      }

      const unknownStates = base.availability.powerStates.Unknown || base.availability.powerStates['Unknown'];
      if (unknownStates) {
        insights.availability.push(`${unknownStates} VMs reported an unknown power state in RVTools.`);
      }

      const toolsTotals = base.manageability.toolsStatus;
      const compliant = toolsTotals['Up to date'] || 0;
      const totalTools = Object.values(toolsTotals).reduce((acc, value) => acc + value, 0);
      const notInstalled = toolsTotals['Not installed'] || 0;
      const outOfDate = toolsTotals['Out of date'] || 0;
      const notRunning = toolsTotals['Not running'] || 0;

      if (totalTools) {
        insights.manageability.push(`${compliant} of ${totalTools} VMs have current VMware Tools.`);
        if (notInstalled) insights.manageability.push(`${notInstalled} VMs do not have VMware Tools installed.`);
        if (outOfDate) insights.manageability.push(`${outOfDate} VMs report outdated VMware Tools. Schedule upgrades.`);
        if (notRunning) insights.manageability.push(`${notRunning} VMs report VMware Tools not running.`);
      } else {
        insights.manageability.push('VMware Tools telemetry not found in the provided exports.');
      }

      const avgCpuPercent = base.performance.cpuPercentSamples ? base.performance.cpuPercentSum / base.performance.cpuPercentSamples : 0;
      const avgCpuMhz = base.performance.cpuMhzSamples ? base.performance.cpuMhzSum / base.performance.cpuMhzSamples : 0;
      const avgMemoryUsage = base.performance.memoryUsageSamples ? base.performance.memoryUsageSumGB / base.performance.memoryUsageSamples : 0;

      if (base.performance.cpuPercentSamples) {
        insights.performance.push(`Average CPU utilisation across sampled VMs is ${avgCpuPercent.toFixed(1)}%.`);
      }
      if (base.performance.cpuMhzSamples) {
        insights.performance.push(`Average CPU consumption is ${avgCpuMhz.toFixed(0)} MHz per VM.`);
      }
      if (base.performance.memoryUsageSamples) {
        insights.performance.push(`Average active memory consumption is ${avgMemoryUsage.toFixed(1)} GB per VM.`);
      }

      const busyVM = vmList
        .filter((vm) => isFinite(vm.cpuUsagePercent))
        .sort((a, b) => b.cpuUsagePercent - a.cpuUsagePercent)[0];
      if (busyVM && busyVM.cpuUsagePercent > 85) {
        insights.performance.push(`${busyVM.name} is consuming ${busyVM.cpuUsagePercent.toFixed(1)}% CPU. Check for right-sizing opportunities.`);
      }

      const vmWithSnapshots = base.recoverability.snapshotDetails.length;
      if (vmWithSnapshots) {
        insights.recoverability.push(`${base.recoverability.totalSnapshots} snapshots detected across ${vmWithSnapshots} VMs.`);
        const aged = base.recoverability.distribution.gte30;
        if (aged) {
          insights.recoverability.push(`${aged} snapshots are older than 30 days. Evaluate removal to reduce risk.`);
        }
        if (base.recoverability.oldestSnapshot) {
          insights.recoverability.push(`Oldest snapshot: ${base.recoverability.oldestSnapshot.vm} (${Math.round(base.recoverability.oldestSnapshot.ageDays)} days).`);
        }
      } else {
        insights.recoverability.push('No snapshot metadata found.');
      }

      if (base.security.flaggedVMs.length) {
        insights.security.push(`${base.security.flaggedVMs.length} VMs are running legacy virtual hardware (< v13).`);
      }
      if (!Object.keys(base.security.hardwareVersions).length) {
        insights.security.push('Virtual hardware metadata unavailable in the provided exports.');
      }

      if (base.cost.totalvCPU || base.cost.totalMemoryGB || base.cost.totalStorageGB) {
        insights.cost.push(`Aggregate estate size: ${base.cost.totalvCPU.toLocaleString()} vCPUs, ${base.cost.totalMemoryGB.toFixed(1)} GB RAM, ${base.cost.totalStorageGB.toFixed(1)} GB storage.`);
        insights.cost.push(`Estimated monthly infrastructure cost: ${formatCurrency(base.cost.estimatedMonthly)} (CPU ${formatCurrency(base.cost.breakdown.cpu)}, RAM ${formatCurrency(base.cost.breakdown.ram)}, Storage ${formatCurrency(base.cost.breakdown.storage)}).`);
      } else {
        insights.cost.push('Capacity data missing. Provide vInfo/vDisk worksheets for costing.');
      }

      if (healthFindings.length) {
        insights.availability.push(`${healthFindings.length} health findings imported from vHealth.`);
      }

      return insights;
    }
    function renderDashboard(data) {
      document.getElementById('fileList').textContent = data.meta.files.join(', ');
      document.getElementById('summary-files').textContent = data.meta.files.length.toString();
      document.getElementById('summary-vms').textContent = data.meta.totalVMs.toString();

      const poweredOn = data.availability.powerStates['Powered on'] || 0;
      const poweredOff = (data.availability.powerStates['Powered off'] || 0) + (data.availability.powerStates['Suspended'] || 0);
      const avgCpuPercent = data.performance.cpuPercentSamples ? data.performance.cpuPercentSum / data.performance.cpuPercentSamples : 0;

      document.getElementById('summary-powered-on').textContent = poweredOn.toString();
      document.getElementById('summary-powered-off').textContent = poweredOff.toString();
      document.getElementById('summary-cpu').textContent = `${avgCpuPercent.toFixed(1)}%`;
      document.getElementById('summary-cost').textContent = formatCurrency(data.cost.estimatedMonthly);

      renderInsights('availability-insights', data.insights.availability);
      renderInsights('manageability-insights', data.insights.manageability);
      renderInsights('performance-insights', data.insights.performance);
      renderInsights('recoverability-insights', data.insights.recoverability);
      renderInsights('security-insights', data.insights.security);
      renderInsights('cost-insights', data.insights.cost);

      renderAvailabilityChart(data.availability.powerStates);
      renderManageabilityChart(data.manageability.toolsStatus);
      renderPerformanceChart({
        avgCpuPercent,
        avgCpuMhz: data.performance.cpuMhzSamples ? data.performance.cpuMhzSum / data.performance.cpuMhzSamples : 0,
        avgMemoryUsage: data.performance.memoryUsageSamples ? data.performance.memoryUsageSumGB / data.performance.memoryUsageSamples : 0,
        totalMemoryProvisioned: data.performance.memoryProvisionedSumGB,
        totalStorageUsed: data.performance.storageUsedSumGB,
      });
      renderRecoverabilityChart(data.recoverability.distribution);
      renderSecurityChart(data.security.hardwareVersions);
      renderCostChart(data.cost.breakdown);

      renderPerformanceTable(data.performance.topVMs);
      renderSnapshotTable(data.recoverability.snapshotDetails);
      renderHealthTable(data.healthFindings);

      toggleEmptyState('availabilityEmpty', Object.values(data.availability.powerStates).some((value) => value > 0));
      toggleEmptyState('manageabilityEmpty', Object.keys(data.manageability.toolsStatus).length);
      toggleEmptyState('performanceEmpty', data.performance.cpuPercentSamples + data.performance.memoryUsageSamples);
      toggleEmptyState('recoverabilityEmpty', data.recoverability.totalSnapshots);
      toggleEmptyState('securityEmpty', Object.keys(data.security.hardwareVersions).length);
      toggleEmptyState('costEmpty', data.cost.totalvCPU + data.cost.totalMemoryGB + data.cost.totalStorageGB);
    }

    function renderInsights(id, insights) {
      const list = document.getElementById(id);
      if (!list) return;
      list.innerHTML = '';
      if (!insights || !insights.length) {
        list.innerHTML = '<li>No insights available.</li>';
        return;
      }
      insights.forEach((item) => {
        const li = document.createElement('li');
        li.textContent = item;
        list.appendChild(li);
      });
    }

    function renderPerformanceTable(rows) {
      const tbody = document.getElementById('performanceTableBody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!rows || !rows.length) {
        tbody.innerHTML = "<tr><td colspan='4'>No performance outliers detected.</td></tr>";
        return;
      }
      rows.forEach((row) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(row.name)}</td>
          <td>${formatMaybeNumber(row.cpuPercent, '%')}</td>
          <td>${formatMaybeNumber(row.cpuMhz, ' MHz')}</td>
          <td>${formatMaybeNumber(row.memoryGB, ' GB')}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderSnapshotTable(rows) {
      const tbody = document.getElementById('snapshotTableBody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!rows || !rows.length) {
        tbody.innerHTML = "<tr><td colspan='4'>No snapshots detected.</td></tr>";
        return;
      }
      rows.slice(0, 8).forEach((row) => {
        const newest = row.newest instanceof Date ? row.newest.toLocaleDateString() : '';
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(row.vm)}</td>
          <td>${row.count}</td>
          <td>${row.oldest ? Math.round(row.oldest) : 'N/A'}</td>
          <td>${newest || 'Unknown'}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderHealthTable(rows) {
      const tbody = document.getElementById('healthTableBody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!rows || !rows.length) {
        tbody.innerHTML = "<tr><td colspan='3'>No vHealth worksheet findings found.</td></tr>";
        return;
      }
      rows.forEach((row) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(row.category || 'General')}</td>
          <td>${escapeHtml(row.finding || '')}</td>
          <td>${escapeHtml(row.object || '')}</td>
        `;
        tbody.appendChild(tr);
      });
    }
    function renderAvailabilityChart(powerStates) {
      const labels = Object.keys(powerStates);
      const values = Object.values(powerStates);
      destroyChart('availabilityChart');
      if (!labels.length || !values.some((value) => value > 0)) {
        document.getElementById('availabilityEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('availabilityEmpty').classList.add('hidden');
      const ctx = document.getElementById('availabilityChart');
      charts.availability = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: generatePalette(labels.length),
              borderWidth: 1,
            },
          ],
        },
        options: {
          plugins: {
            legend: {
              position: 'bottom',
              labels: { color: '#cbd5f5' },
            },
          },
        },
      });
    }

    function renderManageabilityChart(statuses) {
      const labels = Object.keys(statuses);
      const values = Object.values(statuses);
      destroyChart('manageabilityChart');
      if (!labels.length || !values.some((value) => value > 0)) {
        document.getElementById('manageabilityEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('manageabilityEmpty').classList.add('hidden');
      const ctx = document.getElementById('manageabilityChart');
      charts.manageability = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'VM count',
              data: values,
              backgroundColor: generatePalette(labels.length, 60, 55),
            },
          ],
        },
        options: {
          scales: {
            x: {
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.1)' },
            },
            y: {
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.1)' },
            },
          },
          plugins: {
            legend: { display: false },
          },
        },
      });
    }

    function renderPerformanceChart(stats) {
      destroyChart('performanceChart');
      const labels = ['CPU usage %', 'CPU MHz', 'Active memory GB', 'Provisioned memory GB', 'Storage used GB'];
      const data = [
        stats.avgCpuPercent,
        stats.avgCpuMhz,
        stats.avgMemoryUsage,
        stats.totalMemoryProvisioned,
        stats.totalStorageUsed,
      ];
      if (!data.some((value) => isFinite(value) && value > 0)) {
        document.getElementById('performanceEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('performanceEmpty').classList.add('hidden');
      const ctx = document.getElementById('performanceChart');
      charts.performance = new Chart(ctx, {
        type: 'radar',
        data: {
          labels,
          datasets: [
            {
              label: 'Averages & totals',
              data,
              fill: true,
              backgroundColor: 'rgba(14, 165, 233, 0.25)',
              borderColor: 'rgba(56, 189, 248, 0.9)',
              pointBackgroundColor: '#e0f2fe',
            },
          ],
        },
        options: {
          scales: {
            r: {
              angleLines: { color: 'rgba(148, 163, 184, 0.15)' },
              grid: { color: 'rgba(148, 163, 184, 0.15)' },
              pointLabels: { color: '#cbd5f5' },
              ticks: { display: false },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#cbd5f5' },
            },
          },
        },
      });
    }

    function renderRecoverabilityChart(distribution) {
      destroyChart('recoverabilityChart');
      const labels = ['0-7 days', '7-30 days', '30+ days'];
      const values = [distribution.lt7, distribution.lt30, distribution.gte30];
      if (!values.some((value) => value > 0)) {
        document.getElementById('recoverabilityEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('recoverabilityEmpty').classList.add('hidden');
      const ctx = document.getElementById('recoverabilityChart');
      charts.recoverability = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'Snapshots',
              data: values,
              backgroundColor: ['#22d3ee', '#38bdf8', '#0ea5e9'],
            },
          ],
        },
        options: {
          scales: {
            x: {
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.1)' },
            },
            y: {
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.1)' },
              beginAtZero: true,
            },
          },
          plugins: {
            legend: { display: false },
          },
        },
      });
    }

    function renderSecurityChart(hardwareVersions) {
      destroyChart('securityChart');
      const labels = Object.keys(hardwareVersions);
      const values = Object.values(hardwareVersions);
      if (!labels.length) {
        document.getElementById('securityEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('securityEmpty').classList.add('hidden');
      const ctx = document.getElementById('securityChart');
      charts.security = new Chart(ctx, {
        type: 'polarArea',
        data: {
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: generatePalette(labels.length, 55, 60),
              borderWidth: 1,
            },
          ],
        },
        options: {
          plugins: {
            legend: {
              position: 'bottom',
              labels: { color: '#cbd5f5' },
            },
          },
          scales: {
            r: {
              grid: { color: 'rgba(148, 163, 184, 0.15)' },
              angleLines: { color: 'rgba(148, 163, 184, 0.15)' },
              ticks: { display: false },
            },
          },
        },
      });
    }

    function renderCostChart(breakdown) {
      destroyChart('costChart');
      const labels = ['CPU', 'RAM', 'Storage'];
      const values = [breakdown.cpu, breakdown.ram, breakdown.storage];
      if (!values.some((value) => value > 0)) {
        document.getElementById('costEmpty').classList.remove('hidden');
        return;
      }
      document.getElementById('costEmpty').classList.add('hidden');
      const ctx = document.getElementById('costChart');
      charts.cost = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: ['#38bdf8', '#818cf8', '#f472b6'],
            },
          ],
        },
        options: {
          plugins: {
            legend: {
              position: 'bottom',
              labels: { color: '#cbd5f5' },
            },
            tooltip: {
              callbacks: {
                label(context) {
                  return `${context.label}: ${formatCurrency(context.parsed)}`;
                },
              },
            },
          },
        },
      });
    }
    function destroyChart(id) {
      const key = id.replace('Chart', '');
      if (charts[id]) {
        charts[id].destroy();
        charts[id] = null;
      }
      if (charts[key]) {
        charts[key].destroy();
        charts[key] = null;
      }
    }

    function generatePalette(length, saturation = 65, lightness = 55) {
      if (!length) return [];
      const colors = [];
      for (let i = 0; i < length; i += 1) {
        const hue = Math.round((360 / length) * i + 200) % 360;
        colors.push(`hsl(${hue} ${saturation}% ${lightness}%)`);
      }
      return colors;
    }

    function toggleEmptyState(id, hasValue) {
      const el = document.getElementById(id);
      if (!el) return;
      if (hasValue) el.classList.add('hidden');
      else el.classList.remove('hidden');
    }

    function formatPercent(value) {
      if (!isFinite(value)) return '0%';
      return `${(value * 100).toFixed(1)}%`;
    }

    function formatCurrency(value) {
      if (!isFinite(value) || value <= 0) return '$0';
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        maximumFractionDigits: value < 100 ? 2 : 0,
      }).format(value);
    }

    function formatMaybeNumber(value, suffix = '') {
      if (!isFinite(value)) return 'N/A';
      const rounded = Math.abs(value) >= 100 ? value.toFixed(0) : value.toFixed(1);
      return `${rounded}${suffix}`;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return value
        .toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }
  </script>
</body>
</html>
