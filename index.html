<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NexaOrb RVTools Analyzer</title>
  <style>
    :root {
      color-scheme: only light;
      --bg: #ffffff;
      --surface: #f6f7f9;
      --surface-strong: #ffffff;
      --border-color: #d7d9dc;
      --shadow: 0 24px 42px -30px rgba(12, 24, 38, 0.25);
      --text-strong: #111111;
      --text: #1f1f1f;
      --text-subtle: #6b6f76;
      --accent-cyan: #00a9e0;
      --accent-blue: #005587;
      --accent-red: #c8102e;
      --accent-gold: #fdb913;
      --accent-gray: #a7a8aa;
      --accent-green: #3f8e11;
      --radius: 16px;
      --grid-gap: 1.35rem;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Arial', 'Helvetica Neue', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 4rem;
    }


    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--bg);
      border-bottom: 1px solid var(--border-color);
      box-shadow: 0 12px 32px -24px rgba(20, 32, 50, 0.35);
    }

    header .inner {
      max-width: 1600px;
      margin: 0 auto;
      padding: 1.9rem 2.2rem 1.45rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 1.45rem;
      position: relative;
      z-index: 1;
    }

    h1 {
      font-size: clamp(1.8rem, 2vw + 1.1rem, 2.7rem);
      margin: 0;
      font-weight: 700;
      letter-spacing: -0.015em;
      color: var(--accent-red);
    }

    p.lead {
      margin: 0 auto;
      color: var(--text-subtle);
      font-size: 1rem;
      max-width: 760px;
      text-align: center;
    }

    main {
      max-width: 1600px;
      margin: 0 auto;
      padding: 2.4rem 2.2rem 6rem;
      background: var(--bg);
      position: relative;
      isolation: isolate;
    }


    section#dashboards {
      display: grid;
      gap: 1.85rem;
    }

    .card {
      position: relative;
      background: var(--surface-strong);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
      padding: 1.85rem;
      box-shadow: var(--shadow);
      color: var(--text);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .card.capture-mode {
      background: transparent;
      border-color: transparent;
      box-shadow: none;
    }

    .card.capture-mode::after {
      display: none;
    }

    .card::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 4px;
      background: var(--accent-red);
    }

    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 28px 50px -34px rgba(16, 28, 44, 0.45);
    }

    .card h3 {
      margin: 0 0 0.75rem;
      font-size: 1.18rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      color: var(--text-strong);
    }

    .card span.subtitle {
      display: block;
      color: var(--text-subtle);
      font-size: 0.87rem;
      margin-bottom: 1.2rem;
    }

    .card .content {
      margin-top: 0;
    }

    .grid {
      display: grid;
      gap: var(--grid-gap);
    }

    .grid.cols-2 { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
    .grid.cols-3 { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .grid.cols-4 { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }

    .metric-tile {
      position: relative;
      background: var(--surface-strong);
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 18px;
      padding: 1.2rem 1.3rem 1.4rem;
      display: grid;
      gap: 0.4rem;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .metric-tile:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 38px -28px rgba(0, 0, 0, 0.18);
    }

    .metric-tile span.label {
      color: var(--text-subtle);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .metric-tile strong.value {
      font-size: clamp(1.55rem, 2vw + 1rem, 2.55rem);
      font-weight: 600;
      color: var(--accent-cyan);
    }

    canvas { max-width: 100%; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      background: var(--surface-strong);
    }

    table thead {
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      color: #ffffff;
    }

    table thead th {
      text-align: left;
      border-bottom: 2px solid var(--accent-blue);
      padding: 0.6rem 0.6rem;
      background: var(--accent-red);
    }

    table tbody td {
      padding: 0.55rem 0.6rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      color: var(--text);
    }

    table tbody tr:nth-child(odd) td {
      background: rgba(167, 168, 170, 0.12);
    }

    .heat-cell {
      padding: 0.4rem 0.6rem;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.82rem;
      font-weight: 500;
      letter-spacing: 0.02em;
    }

    .heat-red {
      background: rgba(200, 16, 46, 0.12);
      color: #821022;
      border: 1px solid rgba(200, 16, 46, 0.35);
    }

    .heat-amber {
      background: rgba(253, 185, 19, 0.18);
      color: #8a6405;
      border: 1px solid rgba(253, 185, 19, 0.42);
    }

    .heat-green {
      background: rgba(63, 142, 17, 0.14);
      color: #3f5f10;
      border: 1px solid rgba(63, 142, 17, 0.35);
    }

    ul.recommendations {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.5rem;
    }

    ul.recommendations li {
      color: var(--text-subtle);
      line-height: 1.5;
    }

    .flex {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
    }

    .flex > * { flex: 1 1 340px; }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.32rem 0.8rem;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 500;
      border: 1px solid var(--border-color);
      background: var(--surface);
      color: var(--text);
    }

    .pill-green { background: rgba(63, 142, 17, 0.12); color: #3f5f10; border-color: rgba(63, 142, 17, 0.28); }
    .pill-amber { background: rgba(253, 185, 19, 0.18); color: #8a6405; border-color: rgba(253, 185, 19, 0.38); }
    .pill-red { background: rgba(200, 16, 46, 0.12); color: #821022; border-color: rgba(200, 16, 46, 0.32); }
    .pill-slate { background: rgba(167, 168, 170, 0.18); color: #4f5357; border-color: rgba(167, 168, 170, 0.36); }

    .input-group {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .file-input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .file-button {
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
      padding: 0.7rem 1.4rem;
      border-radius: 12px;
      background: var(--accent-blue);
      color: #ffffff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 24px -18px rgba(0, 85, 135, 0.55);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      max-width: 240px;
    }

    .file-button::before {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: #ffffff;
      mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a1 1 0 0 1 1 1v9.585l3.293-3.292a1 1 0 0 1 1.414 1.414l-5.001 5a1 1 0 0 1-1.414 0l-5-5A1 1 0 0 1 7.707 10.3L11 13.586V4a1 1 0 0 1 1-1Zm-7 14a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Z"/></svg>') center / contain no-repeat;
      color: var(--accent-blue);
    }

    .file-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 30px -22px rgba(0, 85, 135, 0.6);
    }

    .file-list {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: var(--text-subtle);
      display: none;
    }

    .file-list ul {
      margin: 0;
      padding-left: 1rem;
      display: grid;
      gap: 0.3rem;
    }

    .notice {
      padding: 0.9rem 1.1rem;
      border-radius: 12px;
      border: 1px solid rgba(0, 169, 224, 0.35);
      background: rgba(0, 169, 224, 0.12);
      color: var(--accent-cyan);
      font-size: 0.88rem;
      margin-top: 0.8rem;
      display: inline-flex;
      gap: 0.55rem;
      align-items: center;
      justify-content: center;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      position: relative;
      padding-left: 2.4rem;
    }

    .notice::before {
      content: '';
      position: absolute;
      left: 1.1rem;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-red);
      box-shadow: 0 0 0 4px rgba(200, 16, 46, 0.1);
    }

    .export-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1.25rem;
    }

    .export-actions button {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 0.68rem 1.4rem;
      font-size: 0.9rem;
      font-weight: 600;
      color: #ffffff;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 12px 24px -18px rgba(0, 85, 135, 0.55);
      background: var(--accent-blue);
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
    }

    .export-actions button::before {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: #ffffff;
      mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a1 1 0 0 1 1 1v9.585l3.293-3.292a1 1 0 0 1 1.414 1.414l-5.001 5a1 1 0 0 1-1.414 0l-5-5A1 1 0 0 1 7.707 10.3L11 13.586V4a1 1 0 0 1 1-1Zm-7 14a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Z"/></svg>') center / contain no-repeat;
      color: var(--accent-blue);
    }

    .export-actions button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }

    .export-actions button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px -22px rgba(0, 85, 135, 0.6);
    }

    .log-section {
      max-width: 1600px;
      margin: 1.5rem auto 0;
      padding: 0 2.2rem 2.6rem;
    }

    .log-panel {
      margin-top: 0;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: var(--surface);
      padding: 1rem;
      max-height: 220px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow);
      position: relative;
    }

    .log-panel::after {
      content: '';
      position: absolute;
      inset: auto -60px -80px;
      height: 180px;
      background: rgba(0, 169, 224, 0.08);
      opacity: 0.4;
      pointer-events: none;
    }

    .log-header {
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-subtle);
      margin-bottom: 0.65rem;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }

    .log-header::before {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: var(--accent-blue);
      mask: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor'><path d='M5 3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h5.268a1 1 0 0 0 .707-.293l1.732-1.732H19a2 2 0 0 0 2-2V8.414a2 2 0 0 0-.586-1.414l-3.414-3.414A2 2 0 0 0 15.586 3H5Zm2 4h6a1 1 0 1 1 0 2H7a1 1 0 1 1 0-2Zm0 4h8a1 1 0 1 1 0 2H7a1 1 0 0 1 0-2Zm0 4h5a1 1 0 1 1 0 2H7a1 1 0 0 1 0-2Z'/></svg>") center/contain no-repeat;
    }

    .log-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      display: grid;
      gap: 0.5rem;
    }

    .log-list li {
      font-size: 0.8rem;
      line-height: 1.4;
      color: var(--text-subtle);
      background: var(--surface-strong);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      display: grid;
      gap: 0.45rem;
    }

    .log-list li span.time {
      font-size: 0.72rem;
      color: rgba(83, 93, 108, 0.7);
      letter-spacing: 0.05em;
    }

    .log-list li span.msg {
      color: var(--text);
      font-size: 0.82rem;
    }

    .log-data {
      margin: 0;
      font-size: 0.72rem;
      background: #eef2f8;
      border-radius: 8px;
      padding: 0.55rem;
      border: 1px solid rgba(0, 169, 224, 0.18);
      color: var(--text-subtle);
      overflow-x: auto;
    }

    .two-column {
      display: grid;
      gap: 1.3rem;
      grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
    }

    .chart-wrapper {
      position: relative;
      background: var(--surface-strong);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      width: 100%;
      padding: 1rem;
      height: min(50vh, 420px);
    }

    .chart-wrapper--radar {
      height: min(50vh, 520px);
    }

    .chart-wrapper canvas {
      display: block;
      position: relative;
      width: 100% !important;
      height: 100% !important;
    }

    .chart-wrapper--wide {
      padding: 1rem 1.2rem 1.4rem;
      height: min(50vh, 480px);
    }

    .table-wrapper {
      overflow-x: auto;
    }

    .muted {
      color: var(--text-subtle);
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      padding: 0.28rem 0.8rem;
      font-size: 0.78rem;
      background: rgba(0, 169, 224, 0.16);
      border: 1px solid rgba(0, 169, 224, 0.38);
      color: var(--accent-cyan);
    }

    .spider-guidance {
      display: grid;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: var(--text-subtle);
    }

    footer {
      max-width: 1600px;
      margin: 0 auto;
      padding: 2.3rem;
      color: var(--text-subtle);
      font-size: 0.82rem;
      text-align: center;
      border-top: 1px solid var(--border-color);
    }

    @media (max-width: 1200px) {
      main { padding: 2rem 1.5rem 5rem; }
    }

    @media (max-width: 768px) {
      header .inner { padding: 1.5rem; }
      main { padding: 1.5rem; }
      .metric-tile { padding: 1rem; }
    }
  </style>
</head>
  <body>
  <header>
    <div class="inner">
      <h1>NexaOrb RVTools Analyzer</h1>
      <p class="lead">Upload one or more RVTools Excel exports to unlock an interactive, auditor-ready analysis of your VMware estate. Metrics, visuals, and best-practice guidance are generated automatically for accelerated assessments.</p>
      <div class="input-group">
        <label class="badge" for="rvtools-input">Multi-vCenter aware</label>
        <label class="file-button" for="rvtools-input">Choose Files</label>
        <input id="rvtools-input" class="file-input" type="file" multiple accept=".xlsx,.xlsm" />
      </div>
      <div class="notice" id="upload-hint">No files imported yet. Select one or more RVTools exports to begin.</div>
      <div id="selected-files" class="file-list"></div>
    </div>
  </header>
  <main>
    <section id="dashboards"></section>
  </main>
  <section class="log-section">
    <div class="log-panel">
      <div class="log-header">Processing Log</div>
      <ul id="process-log" class="log-list"></ul>
    </div>
  </section>
  <footer>
    Built for VMware field engagements. All analysis occurs client-side; no data ever leaves your browser. Hover charts for insights, export elements as needed, and extend the logic inline to match evolving governance policies.
  </footer>

  <template id="dashboard-template">
    <article class="card" id="__ID__">
      <h3>__TITLE__</h3>
      <span class="subtitle">__SUBTITLE__</span>
      <div class="content"></div>
    </article>
  </template>

  <script>
    const LOG_ENTRIES_MAX = 80;
    const XLSX_CDN_URL = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
    const CHARTJS_CDN_URL = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js';
    const HTML2CANVAS_CDN_URL = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
    const PDF_LIB_CDN_URL = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';

    const REQUIRED_SHEETS = [
      'vInfo', 'vCPU', 'vMemory', 'vDisk', 'vPartition', 'vNetwork', 'vCD', 'vUSB',
      'vSnapshot', 'vTools', 'vSource', 'vRP', 'vCluster', 'vHost', 'vNIC', 'vSwitch',
      'vPort', 'dvSwitch', 'dvPort', 'vSC_VMK', 'vDatastore', 'vMultiPath', 'vLicense',
      'vFileInfo', 'vHealth', 'vMetaData'
    ];

    const EOS_CALENDAR = {
      vcenter: {
        '6.0': '2022-03-12',
        '6.5': '2022-10-15',
        '6.7': '2023-10-15',
        '7.0': '2025-04-02',
        '8.0': '2027-10-31'
      },
      esxi: {
        '5.5': '2018-09-19',
        '6.0': '2020-03-12',
        '6.5': '2021-10-15',
        '6.7': '2022-10-15',
        '7.0': '2025-04-02',
        '8.0': '2027-10-31'
      },
      vmtools: {
        '11296': '2019-09-19',
        '11360': '2020-04-02',
        '11420': '2020-11-19',
        '11510': '2021-11-11',
        '11610': '2022-09-15',
        '11700': '2023-10-26',
        '11800': '2024-03-28',
        '12448': '2025-04-04'
      },
      hardware: {
        11: '2020-06-01',
        12: '2020-12-15',
        13: '2021-06-30',
        14: '2022-01-31',
        15: '2022-07-31',
        16: '2023-02-28',
        17: '2023-08-31',
        18: '2024-03-31',
        19: '2024-10-31',
        20: '2025-04-30',
        21: '2026-01-31',
        22: '2026-09-30'
      }
    };

    const SIX_MONTHS_MS = 1000 * 60 * 60 * 24 * 30 * 6;

    const DashboardRegistry = [
      { id: 'dashboard-1', title: 'Dashboard 1 — Environment Summary', subtitle: 'Object totals aggregated across all imported vCenter inventories', build: buildDashboard1 },
      { id: 'dashboard-2', title: 'Dashboard 2 — Overcommit Ratio', subtitle: 'CPU and memory overcommit density by cluster', build: buildDashboard2 },
      { id: 'dashboard-3', title: 'Dashboard 3 — Overcommit Insights', subtitle: 'Tabular ratios and remediation recommendations', build: buildDashboard3 },
      { id: 'dashboard-4', title: 'Dashboard 4 — vCenter & ESXi Version Distribution', subtitle: 'Installed build mix across management and compute planes', build: buildDashboard4 },
      { id: 'dashboard-5', title: 'Dashboard 5 — Version End-of-Support Heatmap', subtitle: 'Lifecycle risk across vCenter and ESXi versions', build: buildDashboard5 },
      { id: 'dashboard-6', title: 'Dashboard 6 — Datastore Free Capacity', subtitle: 'Free space percentage across datastores', build: buildDashboard6 },
      { id: 'dashboard-7', title: 'Dashboard 7 — Datastore Capacity & Free Space', subtitle: 'Capacity breakdown in tebibytes with operational guidance', build: buildDashboard7 },
      { id: 'dashboard-8', title: 'Dashboard 8 — Snapshot Distribution', subtitle: 'Age and size breakdown for snapshots', build: buildDashboard8 },
      { id: 'dashboard-9', title: 'Dashboard 9 — Snapshot Risk Spotlight', subtitle: 'Oldest snapshots and cleanup guidance', build: buildDashboard9 },
      { id: 'dashboard-10', title: 'Dashboard 10 — Consolidation Needed', subtitle: 'VMs requiring snapshot consolidation', build: buildDashboard10 },
      { id: 'dashboard-11', title: 'Dashboard 11 — Consolidation Practices', subtitle: 'Operational recommendations for consolidation backlog', build: buildDashboard11 },
      { id: 'dashboard-12', title: 'Dashboard 12 — Large VM Distribution', subtitle: 'Clusters hosting resource-heavy virtual machines', build: buildDashboard12 },
      { id: 'dashboard-13', title: 'Dashboard 13 — Large VM Spotlight', subtitle: 'Top virtual machines by CPU, memory, and disk footprint', build: buildDashboard13 },
      { id: 'dashboard-14', title: 'Dashboard 14 — Power State Mix', subtitle: 'Powered on versus off virtual machines', build: buildDashboard14 },
      { id: 'dashboard-15', title: 'Dashboard 15 — Powered-Off Workloads', subtitle: 'Rightsize opportunities from powered-off VMs', build: buildDashboard15 },
      { id: 'dashboard-16', title: 'Dashboard 16 — Powered-On Age', subtitle: 'Longest running virtual machines without reboot', build: buildDashboard16 },
      { id: 'dashboard-17', title: 'Dashboard 17 — HA & DRS Coverage', subtitle: 'Cluster-level availability automation posture', build: buildDashboard17 },
      { id: 'dashboard-18', title: 'Dashboard 18 — HA & DRS Matrix', subtitle: 'Per-cluster configuration and recommended actions', build: buildDashboard18 },
      { id: 'dashboard-19', title: 'Dashboard 19 — CD/DVD Connectivity', subtitle: 'VM media device attachment risks', build: buildDashboard19 },
      { id: 'dashboard-20', title: 'Dashboard 20 — CD/DVD Cleanup Plan', subtitle: 'Top VMs with mounted media and remediation tips', build: buildDashboard20 },
      { id: 'dashboard-21', title: 'Dashboard 21 — VMware Tools Posture', subtitle: 'Runtime state and version fragmentation', build: buildDashboard21 },
      { id: 'dashboard-22', title: 'Dashboard 22 — VMware Tools Lifecycle Heatmap', subtitle: 'Out-of-date tools highlight and modernization guidance', build: buildDashboard22 },
      { id: 'dashboard-23', title: 'Dashboard 23 — Port-Group Security', subtitle: 'Promiscuous mode and MAC change posture', build: buildDashboard23 },
      { id: 'dashboard-24', title: 'Dashboard 24 — Port-Group Exceptions', subtitle: 'Sample of permissive port-groups and mitigation', build: buildDashboard24 },
      { id: 'dashboard-25', title: 'Dashboard 25 — Virtual Hardware Versions', subtitle: 'Hardware compatibility distribution across VMs', build: buildDashboard25 },
      { id: 'dashboard-26', title: 'Dashboard 26 — Virtual Hardware Heatmap', subtitle: 'Older hardware levels prioritized for upgrade', build: buildDashboard26 },
      { id: 'dashboard-27', title: 'Dashboard 27 — Template Inventory', subtitle: 'Template to datastore mapping for hygiene checks', build: buildDashboard27 },
      { id: 'dashboard-28', title: 'Dashboard 28 — Latency Sensitivity', subtitle: 'Latency policy adoption across workloads', build: buildDashboard28 },
      { id: 'dashboard-29', title: 'Dashboard 29 — SRM Protection Coverage', subtitle: 'Disaster recovery enrollment by VM', build: buildDashboard29 },
      { id: 'dashboard-30', title: 'Dashboard 30 — SRM Protected Samples', subtitle: 'Sample VMs with SRM protection and follow-up', build: buildDashboard30 },
      { id: 'dashboard-31', title: 'Dashboard 31 — DNS Compliance', subtitle: 'VM hostname attribution status', build: buildDashboard31 },
      { id: 'dashboard-32', title: 'Dashboard 32 — Unknown DNS VMs', subtitle: 'Sample inventory gaps and remediation', build: buildDashboard32 },
      { id: 'dashboard-33', title: 'Dashboard 33 — VM Connection State', subtitle: 'Operational connectivity health across inventory', build: buildDashboard33 },
      { id: 'dashboard-34', title: 'Dashboard 34 — Disconnected VM Spotlight', subtitle: 'Sample disconnected or orphaned VMs', build: buildDashboard34 },
      { id: 'dashboard-35', title: 'Dashboard 35 — Guest OS Alignment', subtitle: 'Configuration versus tools-reported OS drift', build: buildDashboard35 },
      { id: 'dashboard-36', title: 'Dashboard 36 — OS Drift Samples', subtitle: 'Top instances of OS mismatch and explanation', build: buildDashboard36 },
      { id: 'dashboard-37', title: 'Dashboard 37 — NIC Connectivity State', subtitle: 'Connected versus disconnected virtual NICs', build: buildDashboard37 },
      { id: 'dashboard-38', title: 'Dashboard 38 — Disconnected NIC Samples', subtitle: 'Top VMs with disconnected adapters', build: buildDashboard38 },
      { id: 'dashboard-39', title: 'Dashboard 39 — Multi-NIC Virtual Machines', subtitle: 'VMs exceeding single NIC and design considerations', build: buildDashboard39 },
      { id: 'dashboard-40', title: 'Dashboard 40 — Backup Coverage', subtitle: 'Protection status inferred from backup metadata', build: buildDashboard40 },
      { id: 'dashboard-41', title: 'Dashboard 41 — EVC Mode Distribution', subtitle: 'Enhanced vMotion Compatibility posture', build: buildDashboard41 },
      { id: 'dashboard-42', title: 'Dashboard 42 — EVC Inventory', subtitle: 'EVC assignment with improvement guidance', build: buildDashboard42 },
      { id: 'dashboard-43', title: 'Dashboard 43 — Cluster vMotion Activity', subtitle: 'vMotion counts to assess balance and drift', build: buildDashboard43 },
      { id: 'dashboard-44', title: 'Dashboard 44 — Admission Control Status', subtitle: 'Cluster admission control enablement mix', build: buildDashboard44 },
      { id: 'dashboard-45', title: 'Dashboard 45 — Admission Control Matrix', subtitle: 'Cluster-level admission control details', build: buildDashboard45 },
      { id: 'dashboard-46', title: 'Dashboard 46 — CPU & Memory Reservations', subtitle: 'Reservation usage posture across VMs', build: buildDashboard46 },
      { id: 'dashboard-47', title: 'Dashboard 47 — Hot-Add Enablement', subtitle: 'CPU and memory hot-add adoption', build: buildDashboard47 },
      { id: 'dashboard-48', title: 'Dashboard 48 — Large Virtual Disks', subtitle: 'Sample VMs with largest virtual disks', build: buildDashboard48 },
      { id: 'dashboard-49', title: 'Dashboard 49 — Physical Server Vendor Mix', subtitle: 'Vendor and model distribution for ESXi hosts', build: buildDashboard49 },
      { id: 'dashboard-50', title: 'Dashboard 50 — Physical Server Inventory', subtitle: 'Model counts with lifecycle recommendations', build: buildDashboard50 },
      { id: 'dashboard-51', title: 'Dashboard 51 — Host CPU Model Mix', subtitle: 'Processor family diversity across hosts', build: buildDashboard51 },
      { id: 'dashboard-52', title: 'Dashboard 52 — Host CPU Capacity', subtitle: 'CPU topology and total cores per host', build: buildDashboard52 },
      { id: 'dashboard-53', title: 'Dashboard 53 — Uplink Teaming Policy', subtitle: 'Standard and distributed switch teaming strategies', build: buildDashboard53 },
      { id: 'dashboard-54', title: 'Dashboard 54 — VLAN Distribution', subtitle: 'VM demand across VLAN segments', build: buildDashboard54 },
      { id: 'dashboard-55', title: 'Dashboard 55 — Top VLAN Consumers', subtitle: 'High-density VLANs and mitigation', build: buildDashboard55 },
      { id: 'dashboard-56', title: 'Dashboard 56 — VMs per Datastore', subtitle: 'Datastore density hotspots', build: buildDashboard56 },
      { id: 'dashboard-57', title: 'Dashboard 57 — VMs per Host', subtitle: 'Host density and balancing opportunities', build: buildDashboard57 },
      { id: 'dashboard-58', title: 'Dashboard 58 — Multi-Path Policy', subtitle: 'Storage path policy adoption', build: buildDashboard58 },
      { id: 'dashboard-59', title: 'Dashboard 59 — Host DNS & NTP Status', subtitle: 'Core services configurations by host', build: buildDashboard59 },
      { id: 'dashboard-60', title: 'Dashboard 60 — DNS & NTP Gaps', subtitle: 'Hosts missing foundational settings', build: buildDashboard60 },
      { id: 'dashboard-61', title: 'Dashboard 61 — Assessment Radar Diagram', subtitle: 'Six pillar readiness scoring derived from findings', build: buildDashboard61 },
      { id: 'dashboard-62', title: 'Dashboard 62 — 30/60/90 Remediation Plan', subtitle: 'Time-phased actions mapped to availability pillars', build: buildDashboard62 },
      { id: 'dashboard-63', title: 'Dashboard 63 — Health Findings Overview', subtitle: 'Unique vHealth messages with sample objects', build: buildDashboard63 },
      { id: 'dashboard-64', title: 'Dashboard 64 — Export Report', subtitle: 'Export dashboard visuals into a landscape PDF package', build: buildDashboard64 }
    ];

    const ChartStore = new Map();

    const state = {
      data: null,
      metrics: null,
      selectedFiles: []
    };

    const BRAND_COLORS = Object.freeze({
      teal: '#00a9e0',
      red: '#c8102e',
      gold: '#fdb913',
      blue: '#005587',
      gray: '#a7a8aa',
      green: '#3f8e11'
    });

    const GRID_COLOR = 'rgba(167, 168, 170, 0.2)';
    const AXIS_LABEL_COLOR = '#4f5357';

    document.addEventListener('DOMContentLoaded', () => {
      buildLayoutShell();
      document.getElementById('rvtools-input').addEventListener('change', handleFileSelection);
      preloadLibraries();
      logEvent('NexaOrb RVTools Analyzer ready. Import RVTools exports to begin.');
    });

    async function preloadLibraries() {
      try {
        await ensureXlsxReady();
      } catch (error) {
        console.error(error);
        logEvent('Failed to preload XLSX library', { error: error.message });
      }
      try {
        await ensureChartReady();
      } catch (error) {
        console.error(error);
        logEvent('Failed to preload Chart.js library', { error: error.message });
      }
    }

    function buildLayoutShell() {
      const container = document.getElementById('dashboards');
      const template = document.getElementById('dashboard-template').innerHTML;
      DashboardRegistry.forEach(({ id, title, subtitle }) => {
        const html = template.replace('__ID__', id).replace('__TITLE__', title).replace('__SUBTITLE__', subtitle);
        container.insertAdjacentHTML('beforeend', html);
      });
    }

    async function handleFileSelection(event) {
      const files = Array.from(event.target.files);
      if (!files.length) {
        state.selectedFiles = [];
        updateSelectedFiles([], 'Selected files:');
        setUploadHint('No files imported yet. Select one or more RVTools exports to begin.', true);
        logEvent('File selection cleared. Waiting for RVTools exports.');
        return;
      }
      state.selectedFiles = files;
      logEvent('File selection received', {
        count: files.length,
        files: files.map(file => ({ name: file.name, size: file.size }))
      });
      setUploadHint('Processing RVTools workbooks…', false);
      updateSelectedFiles([], 'Selected files:');
      try {
        const raw = await loadWorkbooks(files);
        state.data = raw;
        logEvent('Aggregated workbook data', { workbooks: raw.workbooks.length, sheetsLoaded: raw.sheetsLoaded });
        state.metrics = computeMetrics(raw);
        logEvent('Metrics computed', {
          clusters: state.metrics.clusters.clusterStats.length,
          vms: state.metrics.environment.vms,
          datastores: state.metrics.environment.datastores
        });
        await renderAllDashboards();
        logEvent('Dashboards rendered successfully');
        setUploadHint(`${files.length} workbook${files.length === 1 ? '' : 's'} analyzed.`, false);
        updateSelectedFiles(state.selectedFiles, 'Analyzed workbooks:');
      } catch (error) {
        console.error('Failed to process RVTools workbooks', error);
        logEvent('Processing failed', { error: error.message });
        state.data = null;
        state.metrics = null;
        setUploadHint('Processing failed. Check log for details.', true);
        updateSelectedFiles([], 'Selected files:');
      }
    }

    function setUploadHint(message, isError) {
      const el = document.getElementById('upload-hint');
      if (!el) return;
      el.textContent = message;
      el.style.borderColor = isError ? 'rgba(200, 16, 46, 0.35)' : 'rgba(0, 169, 224, 0.35)';
      el.style.background = isError ? 'rgba(200, 16, 46, 0.1)' : 'rgba(0, 169, 224, 0.12)';
      el.style.color = isError ? '#821022' : '#055f7d';
    }

    function updateSelectedFiles(files, heading = 'Selected files:') {
      const container = document.getElementById('selected-files');
      if (!container) return;
      container.innerHTML = '';
      if (!files || !files.length) {
        container.style.display = 'none';
        return;
      }
      const strong = document.createElement('strong');
      strong.textContent = heading;
      const list = document.createElement('ul');
      files.forEach(file => {
        const li = document.createElement('li');
        li.textContent = file.name;
        list.appendChild(li);
      });
      container.appendChild(strong);
      container.appendChild(list);
      container.style.display = '';
    }

    function logEvent(message, data) {
      const timestamp = new Date().toLocaleTimeString();
      console.log(`[NexaOrb] ${timestamp} — ${message}`, data ?? '');
      const list = document.getElementById('process-log');
      if (!list) return;
      const entry = document.createElement('li');
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time';
      timeSpan.textContent = timestamp;
      const msgSpan = document.createElement('span');
      msgSpan.className = 'msg';
      msgSpan.textContent = message;
      entry.appendChild(timeSpan);
      entry.appendChild(msgSpan);
      if (data !== undefined) {
        const detail = document.createElement('pre');
        detail.className = 'log-data';
        detail.textContent = safelyStringify(data);
        entry.appendChild(detail);
      }
      list.prepend(entry);
      while (list.children.length > LOG_ENTRIES_MAX) {
        list.removeChild(list.lastChild);
      }
    }

    function safelyStringify(data) {
      if (data === null) return 'null';
      if (data === undefined) return 'undefined';
      if (typeof data === 'string') return data;
      try {
        return JSON.stringify(data, (key, value) => {
          if (value instanceof Date) return value.toISOString();
          if (typeof value === 'number' && !Number.isFinite(value)) return value.toString();
          return value;
        }, 2);
      } catch (error) {
        return String(data);
      }
    }

    const libraryPromises = {};

    function ensureScriptLoaded(name, src, globalKey) {
      if (typeof window[globalKey] !== 'undefined') return Promise.resolve();
      if (libraryPromises[name]) return libraryPromises[name];
      libraryPromises[name] = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.referrerPolicy = 'no-referrer';
        script.onload = () => {
          if (typeof window[globalKey] === 'undefined') {
            delete libraryPromises[name];
            reject(new Error(`${name} library loaded but did not expose ${globalKey}`));
            return;
          }
          resolve();
        };
        script.onerror = event => {
          delete libraryPromises[name];
          reject(new Error(`${name} library failed to load (${event?.type || 'unknown'})`));
        };
        document.head.appendChild(script);
      });
      return libraryPromises[name];
    }

    async function ensureXlsxReady() {
      if (window.XLSX) return;
      logEvent('XLSX library not detected. Attempting to load from CDN.', { source: XLSX_CDN_URL });
      await ensureScriptLoaded('XLSX', XLSX_CDN_URL, 'XLSX');
      if (!window.XLSX) {
        throw new Error('XLSX library failed to initialise after loading. Verify network access.');
      }
      logEvent('XLSX library loaded successfully');
    }

    async function ensureChartReady() {
      if (window.Chart) {
        applyChartBranding();
        return;
      }
      logEvent('Chart.js library not detected. Attempting to load from CDN.', { source: CHARTJS_CDN_URL });
      await ensureScriptLoaded('Chart', CHARTJS_CDN_URL, 'Chart');
      if (!window.Chart) {
        throw new Error('Chart.js library failed to initialise after loading. Verify network access.');
      }
      logEvent('Chart.js library loaded successfully');
      applyChartBranding();
    }

    async function ensureCaptureLibReady() {
      if (window.html2canvas) return;
      logEvent('html2canvas library not detected. Attempting to load from CDN.', { source: HTML2CANVAS_CDN_URL });
      await ensureScriptLoaded('html2canvas', HTML2CANVAS_CDN_URL, 'html2canvas');
      if (!window.html2canvas) {
        throw new Error('html2canvas failed to initialise after loading. Verify network access.');
      }
      logEvent('html2canvas library loaded successfully');
    }

    async function ensurePdfLibReady() {
      if (window.jspdf?.jsPDF) return;
      logEvent('jsPDF library not detected. Attempting to load from CDN.', { source: PDF_LIB_CDN_URL });
      await ensureScriptLoaded('jspdf', PDF_LIB_CDN_URL, 'jspdf');
      if (!window.jspdf?.jsPDF) {
        throw new Error('jsPDF failed to initialise after loading. Verify network access.');
      }
      logEvent('jsPDF library loaded successfully');
    }

    async function loadWorkbooks(files) {
      await ensureXlsxReady();
      logEvent('XLSX library ready. Beginning workbook aggregation.');
      const aggregated = createEmptyDataShape();
      logEvent('Workbook aggregation started', { totalFiles: files.length });
      for (const file of files) {
        logEvent('Reading workbook', { workbookId: file.name, size: file.size });
        const buffer = await file.arrayBuffer();
        const workbook = XLSX.read(buffer, { type: 'array' });
        const workbookId = file.name;
        const workbookMeta = {
          workbookId,
          vCenterServer: null,
          vCenterVersion: null,
          generatedAt: null,
          rvtoolsVersion: null
        };

        const sheetStats = {};
        workbook.SheetNames.forEach(sheetName => {
          if (!REQUIRED_SHEETS.includes(sheetName)) return;
          const sheet = workbook.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(sheet, { defval: null, raw: false });
          sheetStats[sheetName] = rows.length;
          rows.forEach(row => {
            if (sheetName === 'vInfo') {
              workbookMeta.vCenterServer = row['VI SDK Server'] || workbookMeta.vCenterServer;
              workbookMeta.vCenterVersion = row['VI SDK Server type'] || workbookMeta.vCenterVersion;
            }
            row.__meta = { workbookId };
            aggregated[sheetName].push(row);
          });
        });

        if (workbook.Sheets['vMetaData']) {
          const metaRows = XLSX.utils.sheet_to_json(workbook.Sheets['vMetaData'], { header: 1, defval: null });
          metaRows.slice(1).forEach(row => {
            const record = {};
            metaRows[0].forEach((key, idx) => {
              record[key] = row[idx];
            });
            workbookMeta.generatedAt = record['xlsx creation datetime'] || workbookMeta.generatedAt;
            workbookMeta.rvtoolsVersion = record['RVTools version'] || workbookMeta.rvtoolsVersion;
            workbookMeta.vCenterServer = record['Server'] || workbookMeta.vCenterServer;
          });
        }
        aggregated.workbooks.push(workbookMeta);
        logEvent('Workbook parsed', { workbookId, sheetStats });
        logEvent('Workbook metadata captured', {
          workbookId,
          vCenterServer: workbookMeta.vCenterServer,
          rvtoolsVersion: workbookMeta.rvtoolsVersion,
          generatedAt: workbookMeta.generatedAt
        });
      }
      aggregated.sheetsLoaded = Object.fromEntries(REQUIRED_SHEETS.map(sheet => [sheet, aggregated[sheet].length]));
      logEvent('Workbook aggregation completed', { sheetsLoaded: aggregated.sheetsLoaded });
      return aggregated;
    }

    function createEmptyDataShape() {
      const shape = { workbooks: [], sheetsLoaded: {} };
      REQUIRED_SHEETS.forEach(name => { shape[name] = []; });
      return shape;
    }

    async function renderAllDashboards() {
      if (!state.metrics) return;
      await ensureChartReady().catch(error => {
        logEvent('Chart.js unavailable. Charts will not render.', { error: error.message });
      });
      logEvent('Rendering dashboards', { dashboardCount: DashboardRegistry.length });
      DashboardRegistry.forEach(({ id, build }) => {
        const card = document.querySelector(`#${id} .content`);
        if (!card) return;
        card.innerHTML = '';
        try {
          build(card, state.metrics, state.data);
        } catch (error) {
          console.error(`Dashboard ${id} failed`, error);
          logEvent(`Dashboard ${id} failed`, { error: error.message });
          card.innerHTML = `<div class="notice" style="color:#821022;background:rgba(200,16,46,0.1);border-color:rgba(200,16,46,0.35)">Unable to render this dashboard. Check console for details.</div>`;
        }
      });
      logEvent('Dashboard rendering complete');
    }

    function computeMetrics(raw) {
      logEvent('Computing metrics from aggregated data', { sheetsLoaded: raw.sheetsLoaded });
      const indexes = buildIndexes(raw);
      logEvent('Indexes built', {
        vmCount: indexes.vms.size,
        clusterCount: indexes.clusters.size,
        hostCount: indexes.hosts.size,
        datastoreCount: indexes.datastores.size
      });
      return {
        raw,
        indexes,
        environment: computeEnvironmentSummary(indexes),
        clusters: computeClusterMetrics(indexes),
        versions: computeVersionMetrics(indexes),
        datastores: computeDatastoreMetrics(indexes),
        snapshots: computeSnapshotMetrics(indexes),
        consolidation: computeConsolidationMetrics(indexes),
        largeVMs: computeLargeVmMetrics(indexes),
        powerStates: computePowerStateMetrics(indexes),
        uptime: computeUptimeMetrics(indexes),
        haDrs: computeHaDrsMetrics(indexes),
        media: computeMediaMetrics(indexes),
        vmTools: computeVmToolsMetrics(indexes),
        networkSecurity: computeNetworkSecurityMetrics(indexes),
        hardware: computeHardwareMetrics(indexes),
        templates: computeTemplateMetrics(indexes),
        latency: computeLatencyMetrics(indexes),
        srm: computeSrmMetrics(indexes),
        dns: computeDnsMetrics(indexes),
        connection: computeConnectionMetrics(indexes),
        osDrift: computeOsDriftMetrics(indexes),
        nic: computeNicMetrics(indexes),
        backups: computeBackupMetrics(indexes),
        evc: computeEvcMetrics(indexes),
        vmotion: computeVmotionMetrics(indexes),
        admission: computeAdmissionMetrics(indexes),
        reservations: computeReservationMetrics(indexes),
        hotAdd: computeHotAddMetrics(indexes),
        disks: computeDiskMetrics(indexes),
        vendors: computeVendorMetrics(indexes),
        cpuModels: computeCpuModelMetrics(indexes),
        teaming: computeTeamingMetrics(indexes),
        vlan: computeVlanMetrics(indexes),
        density: computeDensityMetrics(indexes),
        multiPath: computeMultiPathMetrics(indexes),
        hostServices: computeHostServiceMetrics(indexes),
        health: computeHealthMetrics(raw),
        findings: computeFindings(indexes)
      };
    }

    function buildIndexes(raw) {
      const idx = {
        vms: new Map(),
        clusters: new Map(),
        hosts: new Map(),
        datastores: new Map(),
        portGroups: new Map(),
        vlanToPortGroup: new Map(),
        dvSwitches: [],
        vSwitches: [],
        snapshots: [],
        workbooks: raw.workbooks || [],
        vCenterByWorkbook: new Map(),
        vmDisks: new Map()
      };

      raw.vInfo.forEach(row => {
        const vmName = row['VM'];
        if (!vmName) return;
        const entry = idx.vms.get(vmName) || {
          name: vmName,
          powerState: (row['Powerstate'] || '').toLowerCase(),
          isTemplate: row['Template'] === 'True' || row['Template'] === true,
          srmPlaceholder: row['SRM Placeholder'] === 'True' || row['SRM Placeholder'] === true,
          configStatus: row['Config status'],
          dnsName: row['DNS Name'] || null,
          connectionState: row['Connection state'] || null,
          guestState: row['Guest state'] || null,
          heartbeat: row['Heartbeat'] || null,
          consolidationNeeded: row['Consolidation Needed'] === 'True' || row['Consolidation Needed'] === true,
          powerOnDate: parseDate(row['PowerOn']),
          creationDate: parseDate(row['Creation date']),
          cpus: Number(row['CPUs']) || 0,
          memoryMB: Number(row['Memory']) || 0,
          nicCount: Number(row['NICs']) || 0,
          diskCount: Number(row['Disks']) || 0,
          totalDiskMiB: Number(row['Total disk capacity MiB']) || 0,
          resourcePool: row['Resource pool'] || null,
          cluster: row['Cluster'] || null,
          datacenter: row['Datacenter'] || null,
          host: row['Host'] || null,
          annotation: row['Annotation'] || null,
          rubrikLastBackup: parseDate(row['Rubrik_LastBackup']),
          osConfig: row['OS according to the configuration file'] || null,
          osTools: row['OS according to the VMware Tools'] || null,
          path: row['Path'] || null,
          vmId: row['VM ID'] || null,
          uuid: row['VM UUID'] || null,
          workbookId: row.__meta?.workbookId || null,
          folders: row['Folder'] || null,
          powerOnCount: 0,
          networks: [],
          snapshots: [],
          cdDevices: [],
          vmtools: null,
          hardwareVersion: row['HW version'] ? Number(row['HW version']) || parseFloat(row['HW version']) : null,
          hardwareUpgradeStatus: row['HW upgrade status'] || null,
          latencySensitivity: (row['Latency Sensitivity'] || 'normal').toString().toLowerCase(),
          cpu: {},
          memory: {},
          disks: [],
          connections: [],
          vmServer: row['VI SDK Server'] || null,
          vmServerType: row['VI SDK Server type'] || null
        };
        idx.vms.set(vmName, entry);
      });

      raw.vCPU.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        vm.cpu = {
          sockets: Number(row['Sockets']) || null,
          coresPerSocket: Number(row['Cores p/s']) || null,
          reservation: toNumber(row['Reservation']),
          limit: toNumber(row['Limit']),
          shares: Number(row['Shares']) || null,
          level: row['Level'] || null,
          entitlement: toNumber(row['Entitlement']),
          drsEntitlement: toNumber(row['DRS Entitlement']),
          hotAdd: valueToBool(row['Hot Add']),
          hotRemove: valueToBool(row['Hot Remove'])
        };
      });

      raw.vMemory.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        vm.memory = {
          sizeMB: toNumber(row['Size MiB']),
          reservation: toNumber(row['Reservation']),
          limit: toNumber(row['Limit']),
          shares: Number(row['Shares']) || null,
          level: row['Level'] || null,
          hotAdd: valueToBool(row['Hot Add']),
          active: toNumber(row['Active'])
        };
      });

      raw.vDisk.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        const capacity = toNumber(row['Capacity MiB']);
        vm.disks.push({
          label: row['Disk'],
          capacityMiB: capacity,
          thin: valueToBool(row['Thin']),
          eagerZero: valueToBool(row['Eagerly Scrub']),
          path: row['Path'] || null,
          datastore: extractDatastoreFromPath(row['Path'] || vm.path || '')
        });
        vm.totalDiskMiB += capacity;
        const vmDisk = idx.vmDisks.get(vm.name) || 0;
        idx.vmDisks.set(vm.name, vmDisk + capacity);
      });

      raw.vSnapshot.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        const record = {
          vm: row['VM'],
          name: row['Name'],
          createdAt: parseDate(row['Date / time']),
          sizeMiB: toNumber(row['Size MiB (total)']),
          powerState: row['Powerstate'],
          description: row['Description'] || null,
          datastore: extractDatastoreFromPath(row['Filename'] || ''),
          workbookId: row.__meta?.workbookId || null
        };
        idx.snapshots.push(record);
        if (vm) vm.snapshots.push(record);
      });

      raw.vCD.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        vm.cdDevices.push({
          device: row['Device Node'] || 'CD/DVD drive',
          connected: valueToBool(row['Connected']),
          startsConnected: valueToBool(row['Starts Connected']),
          type: row['Device Type'] || null
        });
      });

      raw.vTools.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        vm.vmtools = {
          status: row['Tools'] || null,
          version: row['Tools Version'] || null,
          requiredVersion: row['Required Version'] || null,
          upgradeable: (row['Upgradeable'] || '').toString().toLowerCase() === 'yes',
          upgradePolicy: row['Upgrade Policy'] || null,
          syncTime: valueToBool(row['Sync time'])
        };
      });

      raw.vNetwork.forEach(row => {
        const vm = idx.vms.get(row['VM']);
        if (!vm) return;
        vm.networks.push({
          label: row['NIC label'] || row['Network adapter'],
          adapter: row['Adapter'] || null,
          network: row['Network'] || null,
          switchName: row['Switch'] || null,
          connected: valueToBool(row['Connected']),
          startsConnected: valueToBool(row['Starts Connected']),
          mac: row['Mac Address'] || null,
          ipv4: row['IPv4 Address'] || null,
          ipv6: row['IPv6 Address'] || null
        });
      });

      raw.vCluster.forEach(row => {
        const clusterName = row['Name'];
        if (!clusterName) return;
        const cluster = idx.clusters.get(clusterName) || {
          name: clusterName,
          datacenter: row['Datacenter'] || null,
          hosts: [],
          totalCpuMhz: toNumber(row['TotalCpu']),
          totalCpuCores: Number(row['NumCpuCores']) || 0,
          totalCpuThreads: Number(row['NumCpuThreads']) || 0,
          totalMemoryMB: toNumber(row['TotalMemory']),
          effectiveMemoryMB: toNumber(row['Effective Memory']),
          numVMotions: Number(row['Num VMotions']) || 0,
          haEnabled: valueToBool(row['HA enabled']),
          haFailoverLevel: Number(row['Failover Level']) || 0,
          admissionControlEnabled: valueToBool(row['AdmissionControlEnabled']),
          haIsolationResponse: row['Isolation Response'] || null,
          vmMonitoring: row['VM Monitoring'] || null,
          drsEnabled: valueToBool(row['DRS enabled']),
          drsBehavior: row['DRS default VM behavior'] || null,
          drsMigrationLevel: Number(row['DRS vmotion rate']) || null,
          dpmEnabled: valueToBool(row['DPM enabled']),
          dpmBehavior: row['DPM default behavior'] || null,
          objectId: row['Object ID'] || null,
          workbookId: row.__meta?.workbookId || null,
          vms: []
        };
        idx.clusters.set(clusterName, cluster);
      });

      raw.vHost.forEach(row => {
        const hostName = row['Host'];
        if (!hostName) return;
        const host = {
          name: hostName,
          datacenter: row['Datacenter'],
          cluster: row['Cluster'],
          configStatus: row['Config status'],
          maintenanceMode: valueToBool(row['in Maintenance Mode']),
          quarantineMode: valueToBool(row['in Quarantine Mode']),
          cpuModel: row['CPU Model'],
          cpuSpeedMHz: Number(row['Speed']) || null,
          cpuPackages: Number(row['# CPU']) || null,
          coresPerCpu: Number(row['Cores per CPU']) || null,
          totalCores: Number(row['# Cores']) || null,
          htEnabled: valueToBool(row['HT Active']),
          memoryMB: toNumber(row['# Memory']),
          memoryUsagePct: toNumber(row['Memory usage %']),
          vmCount: Number(row['# VMs']) || 0,
          totalVmCount: Number(row['# VMs total']) || 0,
          vmPerCore: toNumber(row['VMs per Core']),
          vCpuCount: Number(row['# vCPUs']) || null,
          vCpuPerCore: toNumber(row['vCPUs per Core']),
          vRam: toNumber(row['vRAM']),
          vmUsedMemory: toNumber(row['VM Used memory']),
          vmMemorySwapped: toNumber(row['VM Memory Swapped']),
          vmMemoryBallooned: toNumber(row['VM Memory Ballooned']),
          vmotionSupport: valueToBool(row['VMotion support']),
          storageVmotionSupport: valueToBool(row['Storage VMotion support']),
          currentEvc: row['Current EVC'] || null,
          maxEvc: row['Max EVC'] || null,
          license: row['Assigned License(s)'] || null,
          esxVersion: row['ESX Version'] || null,
          bootTime: parseDate(row['Boot time']),
          dnsServers: row['DNS Servers'] || '',
          dnsConfigured: !!(row['DNS Servers'] && row['DNS Servers'].trim()),
          ntpServers: row['NTP Server(s)'] || '',
          ntpConfigured: !!(row['NTP Server(s)'] && row['NTP Server(s)'].trim()),
          ntpdRunning: valueToBool(row['NTPD running']),
          timezone: row['Time Zone'] || null,
          vendor: row['Vendor'] || null,
          model: row['Model'] || null,
          serial: row['Serial number'] || null,
          evcMode: row['Current EVC'] || null,
          workbookId: row.__meta?.workbookId || null
        };
        idx.hosts.set(hostName, host);
        if (host.cluster && idx.clusters.has(host.cluster)) {
          idx.clusters.get(host.cluster).hosts.push(hostName);
        }
      });

      raw.vDatastore.forEach(row => {
        const name = row['Name'];
        if (!name) return;
        idx.datastores.set(name, {
          name,
          type: row['Type'],
          totalVmCount: Number(row['# VMs total']) || 0,
          connectedVmCount: Number(row['# VMs']) || 0,
          capacityMiB: toNumber(row['Capacity MiB']),
          provisionedMiB: toNumber(row['Provisioned MiB']),
          usedMiB: toNumber(row['In Use MiB']),
          freeMiB: toNumber(row['Free MiB']),
          freePct: toNumber(row['Free %']),
          hosts: (row['Hosts'] || '').split(/,\s*/).filter(Boolean),
          cluster: row['Cluster name'] || null,
          workbookId: row.__meta?.workbookId || null
        });
      });

      raw.vSwitch.forEach(row => {
        idx.vSwitches.push(row);
      });

      raw.dvSwitch.forEach(row => {
        idx.dvSwitches.push(row);
      });

      raw.vPort.forEach(row => {
        const portGroup = row['Port Group'];
        if (!portGroup) return;
        const record = idx.portGroups.get(portGroup) || {
          portGroup,
          switchName: row['Switch'] || null,
          vlan: row['VLAN'] !== undefined && row['VLAN'] !== null ? row['VLAN'].toString() : 'n/a',
          promiscuous: normalizeSecurityValue(row['Promiscuous Mode']),
          macChanges: normalizeSecurityValue(row['Mac Changes']),
          forgedTransmits: normalizeSecurityValue(row['Forged Transmits']),
          policy: row['Policy'] || null,
          hosts: new Set(),
          connectedVMs: 0
        };
        record.hosts.add(row['Host']);
        idx.portGroups.set(portGroup, record);
        idx.vlanToPortGroup.set(portGroup, record.vlan);
      });

      raw.dvPort.forEach(row => {
        const name = row['Port'];
        if (!name) return;
        const vlan = row['VLAN'] !== undefined && row['VLAN'] !== null ? row['VLAN'].toString() : 'n/a';
        idx.vlanToPortGroup.set(name, vlan);
      });

      idx.vms.forEach(vm => {
        vm.networks.forEach(net => {
          if (net.network && idx.portGroups.has(net.network)) {
            idx.portGroups.get(net.network).connectedVMs += 1;
          }
        });
      });

      raw.vInfo.forEach(row => {
        const workbookId = row.__meta?.workbookId;
        if (!workbookId) return;
        const server = row['VI SDK Server'];
        const version = row['VI SDK Server type'];
        if (!idx.vCenterByWorkbook.has(workbookId)) {
          idx.vCenterByWorkbook.set(workbookId, { server, version });
        }
      });

      idx.multiPathEntries = raw.vMultiPath.map(row => ({ ...row }));

      return idx;
    }

    function toNumber(value) {
      if (value === null || value === undefined || value === '') return 0;
      if (typeof value === 'number') return value;
      const numeric = parseFloat(String(value).replace(/[,\s]/g, ''));
      return Number.isFinite(numeric) ? numeric : 0;
    }

    function parseDate(value) {
      if (!value) return null;
      if (value instanceof Date) return value;
      const parsed = new Date(value);
      return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function valueToBool(value) {
      if (typeof value === 'boolean') return value;
      if (value === null || value === undefined) return false;
      const val = String(value).trim().toLowerCase();
      return ['true', 'yes', 'y', '1'].includes(val);
    }

    function pickValue(row, keys) {
      if (!row) return null;
      for (const key of keys) {
        if (!Object.prototype.hasOwnProperty.call(row, key)) continue;
        const value = row[key];
        if (value === null || value === undefined) continue;
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (trimmed) return trimmed;
          continue;
        }
        if (typeof value === 'number') {
          if (Number.isFinite(value)) return value;
          continue;
        }
        if (typeof value === 'boolean') {
          return value;
        }
        const text = String(value).trim();
        if (text) return text;
      }
      return null;
    }

    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/[&<>"']/g, char => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[char]);
    }

    function formatNumber(value) {
      const numeric = Number(value || 0);
      return Number.isFinite(numeric) ? numeric.toLocaleString() : '0';
    }

    function formatDateTime(date) {
      const instance = date instanceof Date ? date : parseDate(date);
      if (!instance) return 'n/a';
      return instance.toLocaleString();
    }

    function formatTimestampForFilename(date) {
      const instance = date instanceof Date ? date : parseDate(date) || new Date();
      const pad = value => String(value).padStart(2, '0');
      return `${instance.getFullYear()}${pad(instance.getMonth() + 1)}${pad(instance.getDate())}-${pad(instance.getHours())}${pad(instance.getMinutes())}${pad(instance.getSeconds())}`;
    }

    function normalizeSecurityValue(value) {
      if (value === null || value === undefined) return 'deny';
      const val = String(value).trim().toLowerCase();
      if (['accept', 'true', 'enabled', 'yes', 'allow'].includes(val)) return 'accept';
      return 'deny';
    }

    function extractDatastoreFromPath(path) {
      if (!path) return null;
      const match = path.match(/\[(.*?)\]/);
      return match ? match[1] : null;
    }

    function computeEnvironmentSummary(idx) {
      const vCenterServers = new Set();
      idx.vms.forEach(vm => { if (vm.vmServer) vCenterServers.add(vm.vmServer); });
      const datacenters = new Set();
      idx.vms.forEach(vm => { if (vm.datacenter) datacenters.add(vm.datacenter); });
      const resourcePools = new Set();
      idx.vms.forEach(vm => { if (vm.resourcePool) resourcePools.add(vm.resourcePool); });
      return {
        vCenters: vCenterServers.size || idx.workbooks.length || idx.vCenterByWorkbook.size,
        datacenters: datacenters.size,
        clusters: idx.clusters.size,
        hosts: idx.hosts.size,
        resourcePools: resourcePools.size,
        vms: Array.from(idx.vms.values()).filter(vm => !vm.isTemplate).length,
        templates: Array.from(idx.vms.values()).filter(vm => vm.isTemplate).length,
        stdSwitches: idx.vSwitches.length,
        dvSwitches: idx.dvSwitches.length,
        datastores: idx.datastores.size
      };
    }

    function computeClusterMetrics(idx) {
      const clusterStats = [];
      idx.clusters.forEach(cluster => {
        const vms = Array.from(idx.vms.values()).filter(vm => vm.cluster === cluster.name && !vm.isTemplate);
        const totalVcpus = vms.reduce((sum, vm) => sum + (vm.cpus || 0), 0);
        const totalMemAlloc = vms.reduce((sum, vm) => sum + (vm.memory?.sizeMB || vm.memoryMB || 0), 0);
        const cpuOvercommit = cluster.totalCpuCores ? totalVcpus / cluster.totalCpuCores : 0;
        const memOvercommit = cluster.totalMemoryMB ? totalMemAlloc / cluster.totalMemoryMB : 0;
        clusterStats.push({
          name: cluster.name,
          datacenter: cluster.datacenter,
          totalVcpus,
          totalMemAlloc,
          cpuOvercommit,
          memOvercommit,
          hostCount: cluster.hosts.length,
          totalCpuCores: cluster.totalCpuCores,
          totalMemoryMB: cluster.totalMemoryMB,
          haEnabled: cluster.haEnabled,
          drsEnabled: cluster.drsEnabled,
          admissionControlEnabled: cluster.admissionControlEnabled,
          numVMotions: cluster.numVMotions
        });
      });
      clusterStats.sort((a, b) => b.cpuOvercommit - a.cpuOvercommit);
      return {
        clusterStats,
        highCpu: clusterStats.filter(c => c.cpuOvercommit > 4),
        highMem: clusterStats.filter(c => c.memOvercommit > 1)
      };
    }

    function computeVersionMetrics(idx) {
      const vCenterCounts = new Map();
      const esxiCounts = new Map();
      idx.vms.forEach(vm => {
        if (vm.vmServerType) {
          const version = vm.vmServerType;
          vCenterCounts.set(version, (vCenterCounts.get(version) || 0) + 1);
        }
      });
      idx.hosts.forEach(host => {
        if (!host.esxVersion) return;
        esxiCounts.set(host.esxVersion, (esxiCounts.get(host.esxVersion) || 0) + 1);
      });

      const normalizeVersion = versionString => {
        if (!versionString) return { major: null, display: versionString, build: null };
        const match = String(versionString).match(/(\d+\.\d+)/);
        const buildMatch = String(versionString).match(/build[- ]?(\d+)/i);
        return {
          major: match ? match[1] : versionString,
          display: versionString,
          build: buildMatch ? buildMatch[1] : null
        };
      };

      const vCenterArray = Array.from(vCenterCounts.entries()).map(([version, count]) => {
        const meta = normalizeVersion(version);
        return { version, count, ...meta };
      });

      const esxiArray = Array.from(esxiCounts.entries()).map(([version, count]) => {
        const meta = normalizeVersion(version);
        return { version, count, ...meta };
      });

      return {
        vCenters: vCenterArray,
        esxi: esxiArray
      };
    }

    function computeDatastoreMetrics(idx) {
      const datastores = Array.from(idx.datastores.values()).map(ds => ({
        ...ds,
        capacityTB: ds.capacityMiB / 1024 / 1024,
        freeTB: ds.freeMiB / 1024 / 1024,
        usedTB: ds.usedMiB / 1024 / 1024
      }));
      datastores.sort((a, b) => a.freePct - b.freePct);
      return {
        datastores,
        lowFree: datastores.filter(ds => ds.freePct < 20)
      };
    }

    function computeSnapshotMetrics(idx) {
      const now = Date.now();
      const categories = {
        age: new Map([
          ['< 7 days', 0],
          ['7-30 days', 0],
          ['30-90 days', 0],
          ['> 90 days', 0]
        ]),
        size: new Map([
          ['< 1 GiB', 0],
          ['1-10 GiB', 0],
          ['10-50 GiB', 0],
          ['> 50 GiB', 0]
        ])
      };

      idx.snapshots.forEach(snap => {
        if (snap.createdAt) {
          const ageDays = (now - snap.createdAt.getTime()) / (1000 * 60 * 60 * 24);
          if (ageDays < 7) categories.age.set('< 7 days', categories.age.get('< 7 days') + 1);
          else if (ageDays < 30) categories.age.set('7-30 days', categories.age.get('7-30 days') + 1);
          else if (ageDays < 90) categories.age.set('30-90 days', categories.age.get('30-90 days') + 1);
          else categories.age.set('> 90 days', categories.age.get('> 90 days') + 1);
        }
        const sizeGiB = (snap.sizeMiB || 0) / 1024;
        if (sizeGiB < 1) categories.size.set('< 1 GiB', categories.size.get('< 1 GiB') + 1);
        else if (sizeGiB < 10) categories.size.set('1-10 GiB', categories.size.get('1-10 GiB') + 1);
        else if (sizeGiB < 50) categories.size.set('10-50 GiB', categories.size.get('10-50 GiB') + 1);
        else categories.size.set('> 50 GiB', categories.size.get('> 50 GiB') + 1);
      });

      const oldestSnapshots = [...idx.snapshots]
        .filter(snap => snap.createdAt)
        .sort((a, b) => a.createdAt - b.createdAt)
        .slice(0, 10);

      const snapshotRisk = [...idx.snapshots].map(snap => {
        const ageDays = snap.createdAt ? (now - snap.createdAt.getTime()) / (1000 * 60 * 60 * 24) : 0;
        const sizeGiB = (snap.sizeMiB || 0) / 1024;
        const riskScore = ageDays * (sizeGiB || 0);
        return { snap, ageDays, sizeGiB, riskScore };
      });
      const highestRiskSnapshots = snapshotRisk
        .filter(entry => entry.ageDays || entry.sizeGiB)
        .sort((a, b) => {
          if (b.riskScore !== a.riskScore) return b.riskScore - a.riskScore;
          if (b.sizeGiB !== a.sizeGiB) return b.sizeGiB - a.sizeGiB;
          return b.ageDays - a.ageDays;
        })
        .slice(0, 10)
        .map(entry => ({
          ...entry.snap,
          ageDays: Math.round(entry.ageDays),
          sizeGiB: Number(entry.sizeGiB.toFixed(2))
        }));

      return {
        totals: idx.snapshots.length,
        categories,
        oldestSnapshots,
        highestRiskSnapshots
      };
    }

    function computeConsolidationMetrics(idx) {
      const vms = Array.from(idx.vms.values());
      const requiringConsolidation = vms.filter(vm => vm.consolidationNeeded);
      return {
        requiringConsolidation,
        counts: {
          true: requiringConsolidation.length,
          false: vms.length - requiringConsolidation.length
        }
      };
    }

    function computeLargeVmMetrics(idx) {
      const threshold = {
        cpu: 16,
        memoryMB: 131072,
        diskMiB: 1024 * 1024
      };
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate && vm.powerState !== 'poweredoff');
      const largeVMs = vms.filter(vm => (vm.cpus || 0) >= threshold.cpu || (vm.memory?.sizeMB || vm.memoryMB || 0) >= threshold.memoryMB || (idx.vmDisks.get(vm.name) || 0) >= threshold.diskMiB);
      const perCluster = new Map();
      largeVMs.forEach(vm => {
        if (!vm.cluster) return;
        perCluster.set(vm.cluster, (perCluster.get(vm.cluster) || 0) + 1);
      });
      const topLarge = [...largeVMs]
        .sort((a, b) => (idx.vmDisks.get(b.name) || 0) - (idx.vmDisks.get(a.name) || 0))
        .slice(0, 5)
        .map(vm => ({
          name: vm.name,
          cluster: vm.cluster,
          cpus: vm.cpus,
          memoryGB: ((vm.memory?.sizeMB || vm.memoryMB || 0) / 1024).toFixed(1),
          diskTB: ((idx.vmDisks.get(vm.name) || 0) / 1024 / 1024).toFixed(2)
        }));
      return {
        largeVMs,
        perCluster: Array.from(perCluster.entries()).map(([cluster, count]) => ({ cluster, count })),
        topLarge
      };
    }

    function computePowerStateMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const counts = vms.reduce((acc, vm) => {
        const key = vm.powerState || 'unknown';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const poweredOff = [...vms]
        .filter(vm => vm.powerState === 'poweredoff')
        .sort((a, b) => (idx.vmDisks.get(b.name) || 0) - (idx.vmDisks.get(a.name) || 0))
        .slice(0, 5)
        .map(vm => ({
          name: vm.name,
          cpus: vm.cpus,
          memoryGB: ((vm.memory?.sizeMB || vm.memoryMB || 0) / 1024).toFixed(1),
          diskTB: ((idx.vmDisks.get(vm.name) || 0) / 1024 / 1024).toFixed(2)
        }));
      return { counts, poweredOff };
    }

    function computeUptimeMetrics(idx) {
      const poweredOn = Array.from(idx.vms.values()).filter(vm => vm.powerState === 'poweredon' && vm.powerOnDate);
      const sorted = poweredOn.sort((a, b) => a.powerOnDate - b.powerOnDate).slice(0, 10).map(vm => ({
        name: vm.name,
        cluster: vm.cluster,
        powerOnDate: vm.powerOnDate,
        days: diffInDays(vm.powerOnDate, new Date()),
        host: vm.host
      }));
      return { poweredOn: sorted };
    }

    function diffInDays(start, end) {
      if (!start || !end) return null;
      return Math.floor((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
    }

    function computeHaDrsMetrics(idx) {
      const clusters = Array.from(idx.clusters.values());
      const haCounts = clusters.reduce((acc, cluster) => {
        const key = cluster.haEnabled ? 'enabled' : 'disabled';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const drsCounts = clusters.reduce((acc, cluster) => {
        const key = cluster.drsEnabled ? 'enabled' : 'disabled';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      return { clusters, haCounts, drsCounts };
    }

    function computeMediaMetrics(idx) {
      const vms = Array.from(idx.vms.values());
      let connected = 0, disconnected = 0;
      const samples = [];
      vms.forEach(vm => {
        vm.cdDevices.forEach(cd => {
          if (cd.connected) connected++; else disconnected++;
        });
        if (vm.cdDevices.some(cd => cd.connected)) {
          samples.push({
            name: vm.name,
            cluster: vm.cluster,
            devices: vm.cdDevices.filter(cd => cd.connected).map(cd => cd.device).join(', ') || 'CD/DVD drive'
          });
        }
      });
      return {
        counts: { connected, disconnected },
        samples: samples.slice(0, 5)
      };
    }

    function computeVmToolsMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const statusCounts = vms.reduce((acc, vm) => {
        const status = vm.vmtools?.status || 'unknown';
        acc[status] = (acc[status] || 0) + 1;
        return acc;
      }, {});
      const versionCounts = new Map();
      const outdated = [];
      vms.forEach(vm => {
        const version = vm.vmtools?.version ? vm.vmtools.version.toString() : 'unknown';
        versionCounts.set(version, (versionCounts.get(version) || 0) + 1);
        if (vm.vmtools?.upgradeable) outdated.push(vm);
      });
      const topVersions = Array.from(versionCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([version, count]) => {
        const eosState = computeLifecycleState(version, EOS_CALENDAR.vmtools);
        return { version, count, eosState };
      });
      return { statusCounts, versionCounts: Array.from(versionCounts.entries()), topVersions, outdated };
    }

    function computeLifecycleState(version, calendar) {
      if (!version) return { state: 'unknown', eosDate: null };
      const today = Date.now();
      const key = Object.keys(calendar).find(key => version.toString().startsWith(key));
      if (!key) return { state: 'unknown', eosDate: null };
      const eosDate = new Date(calendar[key]);
      if (Number.isNaN(eosDate.getTime())) return { state: 'unknown', eosDate: null };
      const remaining = eosDate.getTime() - today;
      if (remaining <= 0) return { state: 'expired', eosDate };
      if (remaining <= SIX_MONTHS_MS) return { state: 'expiring', eosDate };
      return { state: 'healthy', eosDate };
    }

    function computeNetworkSecurityMetrics(idx) {
      const records = Array.from(idx.portGroups.values());
      const promCounts = records.reduce((acc, pg) => {
        acc[pg.promiscuous] = (acc[pg.promiscuous] || 0) + 1;
        return acc;
      }, {});
      const macCounts = records.reduce((acc, pg) => {
        acc[pg.macChanges] = (acc[pg.macChanges] || 0) + 1;
        return acc;
      }, {});
      const permissive = records.filter(pg => pg.promiscuous === 'accept' || pg.macChanges === 'accept');
      return { records, promCounts, macCounts, permissive: permissive.slice(0, 5) };
    }

    function computeHardwareMetrics(idx) {
      const hwLevels = new Map();
      idx.vms.forEach(vm => {
        if (!vm.hardwareVersion) return;
        const version = vm.hardwareVersion;
        const existing = hwLevels.get(version) || { count: 0, state: computeLifecycleState(version, EOS_CALENDAR.hardware) };
        existing.count += 1;
        existing.state = computeLifecycleState(version, EOS_CALENDAR.hardware);
        hwLevels.set(version, existing);
      });
      return { vmHardware: hwLevels };
    }

    function computeTemplateMetrics(idx) {
      const templates = Array.from(idx.vms.values()).filter(vm => vm.isTemplate).map(vm => ({
        name: vm.name,
        datastore: vm.disks[0]?.datastore || extractDatastoreFromPath(vm.path || '') || 'n/a',
        cluster: vm.cluster
      }));
      return { templates };
    }

    function computeLatencyMetrics(idx) {
      const vms = Array.from(idx.vms.values());
      const sensitivityCounts = { Normal: 0, High: 0 };
      vms.forEach(vm => {
        const value = (vm.latencySensitivity || 'normal').toLowerCase();
        if (value === 'high') sensitivityCounts.High += 1;
        else sensitivityCounts.Normal += 1;
      });
      return { sensitivityCounts };
    }

    function computeSrmMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const protectedVms = vms.filter(vm => vm.srmPlaceholder);
      return {
        counts: {
          protected: protectedVms.length,
          unprotected: vms.length - protectedVms.length
        },
        samples: protectedVms.slice(0, 5).map(vm => ({
          name: vm.name,
          cluster: vm.cluster,
          host: vm.host,
          datastore: vm.disks[0]?.datastore || extractDatastoreFromPath(vm.path || '') || 'n/a',
          network: vm.networks[0]?.network || 'n/a'
        }))
      };
    }

    function computeDnsMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const known = vms.filter(vm => vm.dnsName);
      const unknown = vms.filter(vm => !vm.dnsName);
      return {
        counts: { known: known.length, unknown: unknown.length },
        unknown: unknown.slice(0, 5).map(vm => ({
          name: vm.name,
          cluster: vm.cluster,
          host: vm.host
        }))
      };
    }

    function computeConnectionMetrics(idx) {
      const vms = Array.from(idx.vms.values());
      const counts = vms.reduce((acc, vm) => {
        const key = vm.connectionState || 'unknown';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const problematic = vms.filter(vm => ['disconnected', 'inaccessible', 'invalid', 'orphaned'].includes((vm.connectionState || '').toLowerCase()));
      return {
        counts,
        problematic: problematic.slice(0, 5).map(vm => ({
          name: vm.name,
          cluster: vm.cluster,
          state: vm.connectionState
        }))
      };
    }

    function computeOsDriftMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const drift = vms.filter(vm => vm.osConfig && vm.osTools && vm.osConfig !== vm.osTools);
      return {
        align: vms.length - drift.length,
        drift: drift.length,
        samples: drift.slice(0, 5).map(vm => ({
          name: vm.name,
          cluster: vm.cluster,
          osConfig: vm.osConfig,
          osTools: vm.osTools
        }))
      };
    }

    function computeNicMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const nicStates = { connected: 0, disconnected: 0 };
      const multiNic = [];
      vms.forEach(vm => {
        const disconnected = vm.networks.filter(net => !net.connected);
        nicStates.connected += vm.networks.length - disconnected.length;
        nicStates.disconnected += disconnected.length;
        if (vm.networks.length > 1) multiNic.push({
          name: vm.name,
          adapters: vm.networks.length,
          cluster: vm.cluster
        });
      });
      const disconnectedVMs = vms.filter(vm => vm.networks.every(net => !net.connected)).slice(0, 10).map(vm => ({
        name: vm.name,
        adapters: vm.networks.length,
        cluster: vm.cluster
      }));
      return { nicStates, disconnectedVMs, multiNic: multiNic.slice(0, 10) };
    }

    function computeBackupMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const protectedVms = vms.filter(vm => !!vm.rubrikLastBackup);
      const unprotected = vms.length - protectedVms.length;
      return {
        counts: { protected: protectedVms.length, unprotected },
        protectedVms,
        recommendations: {
          oldestBackup: protectedVms.sort((a, b) => a.rubrikLastBackup - b.rubrikLastBackup)[0]
        }
      };
    }

    function computeEvcMetrics(idx) {
      const hosts = Array.from(idx.hosts.values());
      const counts = hosts.reduce((acc, host) => {
        const key = host.currentEvc || 'Not Configured';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const summary = Object.entries(counts).map(([evc, count]) => ({ evc, count }));
      return { counts, summary };
    }

    function computeVmotionMetrics(idx) {
      const clusters = Array.from(idx.clusters.values()).map(cluster => ({
        name: cluster.name,
        vmotions: cluster.numVMotions || 0
      }));
      clusters.sort((a, b) => b.vmotions - a.vmotions);
      return { clusters, topClusters: clusters.slice(0, 10) };
    }

    function computeAdmissionMetrics(idx) {
      const clusters = Array.from(idx.clusters.values());
      const counts = clusters.reduce((acc, cluster) => {
        const key = cluster.admissionControlEnabled ? 'enabled' : 'disabled';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      return { clusters, counts };
    }

    function computeReservationMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const cpuReserved = vms.filter(vm => (vm.cpu?.reservation || 0) > 0);
      const memReserved = vms.filter(vm => (vm.memory?.reservation || 0) > 0);
      return {
        counts: {
          cpu: { yes: cpuReserved.length, no: vms.length - cpuReserved.length },
          memory: { yes: memReserved.length, no: vms.length - memReserved.length }
        },
        cpuReserved: cpuReserved.slice(0, 5),
        memReserved: memReserved.slice(0, 5)
      };
    }

    function computeHotAddMetrics(idx) {
      const vms = Array.from(idx.vms.values()).filter(vm => !vm.isTemplate);
      const cpuHotAdd = vms.filter(vm => vm.cpu?.hotAdd);
      const memHotAdd = vms.filter(vm => vm.memory?.hotAdd);
      return {
        counts: {
          cpu: { yes: cpuHotAdd.length, no: vms.length - cpuHotAdd.length },
          memory: { yes: memHotAdd.length, no: vms.length - memHotAdd.length }
        }
      };
    }

    function computeDiskMetrics(idx) {
      const disks = [];
      idx.vms.forEach(vm => {
        vm.disks.forEach(disk => {
          disks.push({
            vm: vm.name,
            cluster: vm.cluster,
            label: disk.label,
            capacityMiB: disk.capacityMiB,
            datastore: disk.datastore
          });
        });
      });
      const largestDisks = disks.sort((a, b) => b.capacityMiB - a.capacityMiB).slice(0, 10).map(d => ({
        vm: d.vm,
        cluster: d.cluster,
        label: d.label,
        sizeTB: (d.capacityMiB / 1024 / 1024).toFixed(2),
        datastore: d.datastore
      }));
      return { largestDisks };
    }

    function computeVendorMetrics(idx) {
      const hosts = Array.from(idx.hosts.values());
      const vendorModelCounts = new Map();
      hosts.forEach(host => {
        const key = `${host.vendor || 'Unknown'} — ${host.model || 'Unknown'}`;
        vendorModelCounts.set(key, (vendorModelCounts.get(key) || 0) + 1);
      });
      const vendorCounts = new Map();
      hosts.forEach(host => {
        const vendor = host.vendor || 'Unknown';
        vendorCounts.set(vendor, (vendorCounts.get(vendor) || 0) + 1);
      });
      const vendorCountsArray = Array.from(vendorCounts.entries()).sort((a, b) => b[1] - a[1]);
      const vendorModelCountArray = Array.from(vendorModelCounts.entries()).map(([combo, count]) => {
        const [vendor, model] = combo.split(' — ');
        return { vendor, model, count };
      }).sort((a, b) => b.count - a.count || a.vendor.localeCompare(b.vendor));
      return {
        vendorCounts: vendorCountsArray,
        vendorModelCounts: vendorModelCountArray
      };
    }

    function computeCpuModelMetrics(idx) {
      const hosts = Array.from(idx.hosts.values());
      const cpuCounts = new Map();
      const modelSummariesMap = new Map();
      hosts.forEach(host => {
        const cpu = host.cpuModel || 'Unknown';
        cpuCounts.set(cpu, (cpuCounts.get(cpu) || 0) + 1);
        const entry = modelSummariesMap.get(cpu) || { model: cpu, hostCount: 0, totalCores: 0, totalPackages: 0 };
        entry.hostCount += 1;
        entry.totalCores += host.totalCores || 0;
        entry.totalPackages += host.cpuPackages || 0;
        modelSummariesMap.set(cpu, entry);
      });
      const hostDetails = hosts.map(host => ({
        host: host.name,
        cpuModel: host.cpuModel,
        cpuPackages: host.cpuPackages,
        coresPerCpu: host.coresPerCpu,
        totalCores: host.totalCores
      }));
      const modelSummaries = Array.from(modelSummariesMap.values()).map(entry => ({
        ...entry,
        avgCoresPerHost: entry.hostCount ? entry.totalCores / entry.hostCount : 0
      })).sort((a, b) => b.hostCount - a.hostCount || b.totalCores - a.totalCores || a.model.localeCompare(b.model));
      const totalCores = hosts.reduce((sum, host) => sum + (host.totalCores || 0), 0);
      return {
        cpuCounts: Array.from(cpuCounts.entries()).sort((a, b) => b[1] - a[1]),
        hostDetails,
        modelSummaries,
        totalCores
      };
    }

    function computeHealthMetrics(raw) {
      const rows = Array.isArray(raw.vHealth) ? raw.vHealth : [];
      if (!rows.length) {
        return { messages: [] };
      }
      const groups = new Map();
      rows.forEach(row => {
        const message = pickValue(row, ['Message', 'Issue', 'Type', 'Finding', 'Description']);
        if (!message) return;
        const key = message;
        const entry = groups.get(key) || { message: key, count: 0, sampleObject: null, sampleDetail: null };
        entry.count += 1;
        if (!entry.sampleObject) {
          entry.sampleObject = pickValue(row, ['Object', 'Name', 'Item', 'Target', 'Entity', 'VM', 'Host', 'Datastore', 'Resource', 'Configuration name']);
        }
        if (!entry.sampleDetail) {
          entry.sampleDetail = pickValue(row, ['Configuration', 'Setting', 'Value', 'Details', 'Path', 'Comment', 'Recommendation']);
        }
        groups.set(key, entry);
      });
      const messages = Array.from(groups.values()).sort((a, b) => b.count - a.count || a.message.localeCompare(b.message));
      return { messages };
    }

    function computeTeamingMetrics(idx) {
      const policies = new Map();
      idx.portGroups.forEach(pg => {
        const policy = pg.policy || pg.switchPolicy || pg.portPolicy || 'unknown';
        const normalized = policy || 'load-balance srcid';
        policies.set(normalized, (policies.get(normalized) || 0) + 1);
      });
      return { policies: Array.from(policies.entries()) };
    }

    function computeVlanMetrics(idx) {
      const vlanCounts = new Map();
      idx.portGroups.forEach(pg => {
        const vlan = pg.vlan || 'n/a';
        vlanCounts.set(vlan, (vlanCounts.get(vlan) || 0) + pg.connectedVMs);
      });
      const ordered = Array.from(vlanCounts.entries()).sort((a, b) => b[1] - a[1]);
      return { vlanCounts: ordered, topVLANs: ordered.slice(0, 5) };
    }

    function computeDensityMetrics(idx) {
      const datastores = Array.from(idx.datastores.values())
        .sort((a, b) => (b.totalVmCount || 0) - (a.totalVmCount || 0))
        .slice(0, 5)
        .map(ds => ({ name: ds.name, vmCount: ds.totalVmCount }));
      const hosts = Array.from(idx.hosts.values())
        .sort((a, b) => (b.totalVmCount || 0) - (a.totalVmCount || 0))
        .slice(0, 5)
        .map(host => ({ name: host.name, vmCount: host.totalVmCount }));
      return { datastores, hosts };
    }

    function computeMultiPathMetrics(idx) {
      const mpPolicies = new Map();
      (idx.multiPathEntries || []).forEach(entry => {
        const policy = entry['Policy'] || 'Unknown';
        mpPolicies.set(policy, (mpPolicies.get(policy) || 0) + 1);
      });
      return { policies: Array.from(mpPolicies.entries()) };
    }

    function computeHostServiceMetrics(idx) {
      const hosts = Array.from(idx.hosts.values());
      const dns = { configured: 0, 'not configured': 0 };
      const ntp = { configured: 0, 'not configured': 0 };
      hosts.forEach(host => {
        if (host.dnsConfigured) dns.configured += 1;
        else dns['not configured'] += 1;
        if (host.ntpConfigured) ntp.configured += 1;
        else ntp['not configured'] += 1;
      });
      const gaps = hosts.filter(host => !host.dnsConfigured || !host.ntpConfigured).slice(0, 5).map(host => ({
        name: host.name,
        dnsConfigured: host.dnsConfigured,
        ntpConfigured: host.ntpConfigured
      }));
      const totals = {
        totalHosts: hosts.length,
        dns: {
          configured: dns.configured,
          notConfigured: dns['not configured']
        },
        ntp: {
          configured: ntp.configured,
          notConfigured: ntp['not configured']
        }
      };
      return { dns, ntp, gaps, totals };
    }

    function computeFindings(idx) {
      const findings = [];
      const metrics = {
        lowDatastores: computeDatastoreMetrics(idx).lowFree,
        highCpu: computeClusterMetrics(idx).highCpu,
        highMem: computeClusterMetrics(idx).highMem,
        snapshots: computeSnapshotMetrics(idx).oldestSnapshots
      };
      if (metrics.lowDatastores.length) {
        findings.push({
          pillar: 'Availability',
          title: 'Low datastore free capacity',
          detail: `${metrics.lowDatastores.length} datastore(s) below 20% free capacity.`
        });
      }
      if (metrics.highCpu.length) {
        findings.push({
          pillar: 'Performance',
          title: 'CPU overcommit beyond 4:1',
          detail: `${metrics.highCpu.length} cluster(s) exceed CPU overcommit guidance.`
        });
      }
      if (metrics.highMem.length) {
        findings.push({
          pillar: 'Performance',
          title: 'Memory overcommit beyond 1:1',
          detail: `${metrics.highMem.length} cluster(s) need memory rebalancing.`
        });
      }
      if (metrics.snapshots.length) {
        findings.push({
          pillar: 'Manageability',
          title: 'Ageing snapshots detected',
          detail: 'Oldest snapshot exceeds 90 days; clean-up recommended.'
        });
      }
      return findings;
    }

    function collectReportInsights(metrics, data) {
      const environment = metrics?.environment || {};
      const datastores = metrics?.datastores?.lowFree || [];
      const riskySnapshots = metrics?.snapshots?.highestRiskSnapshots || metrics?.snapshots?.oldestSnapshots || [];
      const unprotected = metrics?.backups?.counts?.unprotected || 0;
      const dnsGaps = metrics?.hostServices?.totals?.dns?.notConfigured || 0;
      const ntpGaps = metrics?.hostServices?.totals?.ntp?.notConfigured || 0;
      const findings = Array.isArray(metrics?.findings) ? metrics.findings.slice(0, 5) : [];

      const riskAreas = [];
      if (datastores.length) {
        riskAreas.push(`${formatNumber(datastores.length)} datastore${datastores.length === 1 ? '' : 's'} below 20% free capacity.`);
      }
      if (riskySnapshots.length) {
        riskAreas.push(`${formatNumber(riskySnapshots.length)} snapshot${riskySnapshots.length === 1 ? '' : 's'} exceeding age or size thresholds.`);
      }
      if (unprotected) {
        riskAreas.push(`${formatNumber(unprotected)} VM${unprotected === 1 ? '' : 's'} without backup coverage.`);
      }
      if (dnsGaps) {
        riskAreas.push(`${formatNumber(dnsGaps)} host${dnsGaps === 1 ? '' : 's'} missing DNS configuration.`);
      }
      if (ntpGaps) {
        riskAreas.push(`${formatNumber(ntpGaps)} host${ntpGaps === 1 ? '' : 's'} missing NTP configuration.`);
      }
      if (!riskAreas.length) {
        riskAreas.push('No major risk indicators detected in this analysis window. Maintain current guardrails.');
      }

      const recommendations = [];
      if (datastores.length) {
        recommendations.push('Expand or reclaim capacity on datastores flagged under 20% free space.');
      }
      if (riskySnapshots.length) {
        recommendations.push('Enforce snapshot retention policy and consolidate aged deltas exceeding 30 days.');
      }
      if (unprotected) {
        recommendations.push('Onboard unprotected VMs into the enterprise backup policy or validate intentional exclusions.');
      }
      if (dnsGaps || ntpGaps) {
        recommendations.push('Standardize DNS/NTP configuration across ESXi hosts via host profiles or desired state tooling.');
      }
      if (!recommendations.length) {
        recommendations.push('Sustain platform hygiene and schedule the next assessment checkpoint within 90 days.');
      }

      const workbooks = Array.isArray(data?.workbooks) ? data.workbooks : [];
      const generatedAt = workbooks
        .map(entry => parseDate(entry.generatedAt))
        .filter(Boolean)
        .sort((a, b) => b - a)[0] || new Date();

      return {
        environment: {
          vms: environment.vms || 0,
          hosts: environment.hosts || 0,
          clusters: environment.clusters || 0,
          datacenters: environment.datacenters || 0,
          datastores: metrics?.datastores?.datastores?.length || environment.datastores || 0
        },
        riskAreas,
        findings,
        recommendations,
        generatedAt,
        workbookCount: workbooks.length
      };
    }

    function downloadFile(filename, blob) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    async function exportPdfReport() {
      await ensurePdfLibReady();
      const insights = collectReportInsights(state.metrics, state.data);
      const captures = await captureDashboardImages();
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const margin = 48;
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const exportedAt = new Date();

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(24);
      doc.text('NexaOrb RVTools Dashboard Report', margin, margin + 8);
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(12);
      doc.text(`Generated on ${formatDateTime(exportedAt)}`, margin, margin + 30);

      let cursorY = margin + 58;
      const ensureSpace = heightNeeded => {
        if (cursorY + heightNeeded > pageHeight - margin) {
          doc.addPage();
          cursorY = margin;
        }
      };

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      doc.text('Environment Overview', margin, cursorY);
      cursorY += 18;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(11);
      [
        `Virtual Machines: ${formatNumber(insights.environment.vms)}`,
        `Hosts: ${formatNumber(insights.environment.hosts)}`,
        `Clusters: ${formatNumber(insights.environment.clusters)}`,
        `Datacenters: ${formatNumber(insights.environment.datacenters)}`,
        `Datastores: ${formatNumber(insights.environment.datastores)}`
      ].forEach(line => {
        ensureSpace(14);
        doc.text(line, margin, cursorY);
        cursorY += 14;
      });
      cursorY += 10;

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      ensureSpace(18);
      doc.text('Top Risk Signals', margin, cursorY);
      cursorY += 18;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(11);
      insights.riskAreas.forEach(line => {
        ensureSpace(14 * (doc.splitTextToSize(line, pageWidth - margin * 2).length));
        doc.splitTextToSize(`• ${line}`, pageWidth - margin * 2).forEach(segment => {
          doc.text(segment, margin, cursorY);
          cursorY += 14;
        });
      });
      cursorY += 10;

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      ensureSpace(18);
      doc.text('Highlighted Findings', margin, cursorY);
      cursorY += 18;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(11);
      const findingLines = insights.findings.length
        ? insights.findings.map(f => `• [${f.pillar}] ${f.title} — ${f.detail}`)
        : ['No major findings were highlighted in this run.'];
      findingLines.forEach(line => {
        ensureSpace(14 * (doc.splitTextToSize(line, pageWidth - margin * 2).length));
        doc.splitTextToSize(line, pageWidth - margin * 2).forEach(segment => {
          doc.text(segment, margin, cursorY);
          cursorY += 14;
        });
      });
      cursorY += 10;

      doc.setFont('helvetica', 'bold');
      doc.setFontSize(14);
      ensureSpace(18);
      doc.text('Recommended Actions', margin, cursorY);
      cursorY += 18;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(11);
      insights.recommendations.forEach(line => {
        ensureSpace(14 * (doc.splitTextToSize(line, pageWidth - margin * 2).length));
        doc.splitTextToSize(`• ${line}`, pageWidth - margin * 2).forEach(segment => {
          doc.text(segment, margin, cursorY);
          cursorY += 14;
        });
      });

      captures.forEach(capture => {
        doc.addPage();
        const imgProps = doc.getImageProperties(capture.dataUrl);
        const availableWidth = pageWidth - margin * 2;
        const availableHeight = pageHeight - margin * 2;
        const scale = Math.min(availableWidth / imgProps.width, availableHeight / imgProps.height);
        const drawWidth = imgProps.width * scale;
        const drawHeight = imgProps.height * scale;
        const imgX = margin + (availableWidth - drawWidth) / 2;
        const imgY = margin + (availableHeight - drawHeight) / 2;
        doc.addImage(capture.dataUrl, 'PNG', imgX, imgY, drawWidth, drawHeight, undefined, 'FAST');
      });

      doc.save(`nexaorb-rvtools-dashboards-${formatTimestampForFilename(exportedAt)}.pdf`);
    }

    function createMetricTile(label, value, description) {
      const tile = document.createElement('div');
      tile.className = 'metric-tile';
      tile.innerHTML = `
        <span class="label">${label}</span>
        <strong class="value">${value}</strong>
        ${description ? `<span class="muted">${description}</span>` : ''}
      `;
      return tile;
    }

    function createChartContainer(id, type, extraClass) {
      const classes = ['chart-wrapper'];
      if (type === 'radar') classes.push('chart-wrapper--radar');
      if (extraClass) classes.push(extraClass);
      const wrapper = document.createElement('div');
      wrapper.className = classes.join(' ');
      const canvas = document.createElement('canvas');
      canvas.id = id;
      if (type === 'radar') {
        canvas.width = 800;
        canvas.height = 800;
      }
      if (type === 'pie') {
        canvas.width = 800;
        canvas.height = 800;
      }
      wrapper.appendChild(canvas);
      return wrapper;
    }

    function createTable(headers, rows) {
      const wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      rows.forEach(row => {
        const tr = document.createElement('tr');
        row.forEach(cell => {
          const td = document.createElement('td');
          if (typeof cell === 'string' || typeof cell === 'number') {
            td.textContent = cell;
          } else if (cell instanceof HTMLElement) {
            td.appendChild(cell);
          } else if (cell && cell.html) {
            td.innerHTML = cell.html;
          } else {
            td.textContent = cell ?? '';
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      wrapper.appendChild(table);
      return wrapper;
    }

    function createRecommendationList(items) {
      const ul = document.createElement('ul');
      ul.className = 'recommendations';
      items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        ul.appendChild(li);
      });
      return ul;
    }

    async function captureDashboardImages() {
      await ensureCaptureLibReady();
      const cards = Array.from(document.querySelectorAll('#dashboards .card'))
        .filter(card => card.id !== 'dashboard-64');
      const captures = [];
      for (const card of cards) {
        const title = card.querySelector('h3')?.textContent || 'Dashboard';
        try {
          card.classList.add('capture-mode');
          const canvas = await window.html2canvas(card, {
            backgroundColor: '#ffffff',
            scale: Math.min(window.devicePixelRatio || 1, 2)
          });
          captures.push({ title, dataUrl: canvas.toDataURL('image/png') });
        } catch (error) {
          console.error('Failed to capture dashboard', title, error);
          logEvent('Dashboard capture failed', { dashboard: title, error: error.message });
        } finally {
          card.classList.remove('capture-mode');
        }
      }
      return captures;
    }

    function createExportButton(label, format) {
      const button = document.createElement('button');
      button.type = 'button';
      button.dataset.format = format;
      button.textContent = label;
      button.addEventListener('click', async () => {
        if (!state.metrics) {
          logEvent('Export attempt ignored. Metrics unavailable.', { format });
          return;
        }
        button.disabled = true;
        try {
          if (format === 'pdf') {
            await exportPdfReport();
            logEvent('PDF report exported successfully');
          } else {
            logEvent('Unsupported export format requested', { format });
          }
        } catch (error) {
          console.error(error);
          logEvent('Report export failed', { format, error: error.message });
        } finally {
          button.disabled = false;
        }
      });
      return button;
    }

    function createNoDataNotice(message = 'No data available for this visualization.') {
      const div = document.createElement('div');
      div.className = 'notice no-data-message';
      div.style.marginTop = '0';
      div.textContent = message;
      return div;
    }

    function hasChartData(config) {
      if (!config?.data?.datasets?.length) return false;
      return config.data.datasets.some(dataset => Array.isArray(dataset.data) && dataset.data.some(value => {
        const numeric = typeof value === 'number' ? value : parseFloat(value);
        return Number.isFinite(numeric) && numeric !== 0;
      }));
    }

    function applyChartBranding() {
      if (!window.Chart || applyChartBranding.applied) return;
      const { Chart } = window;
      Chart.defaults.font.family = 'Arial, "Helvetica Neue", sans-serif';
      Chart.defaults.color = AXIS_LABEL_COLOR;
      Chart.defaults.borderColor = GRID_COLOR;
      Chart.defaults.maintainAspectRatio = false;
      Chart.defaults.plugins.legend.labels.color = AXIS_LABEL_COLOR;
      Chart.defaults.plugins.legend.labels.usePointStyle = true;
      Chart.defaults.plugins.tooltip.titleColor = AXIS_LABEL_COLOR;
      Chart.defaults.plugins.tooltip.bodyColor = AXIS_LABEL_COLOR;
      Chart.defaults.plugins.tooltip.backgroundColor = '#ffffff';
      Chart.defaults.plugins.tooltip.borderColor = GRID_COLOR;
      Chart.defaults.plugins.tooltip.borderWidth = 1;
      applyChartBranding.applied = true;
    }

    function renderChart(id, config) {
      const canvas = document.getElementById(id);
      if (!canvas) return null;
      const parent = canvas.parentElement;
      if (!hasChartData(config)) {
        if (parent) {
          canvas.style.display = 'none';
          if (!parent.querySelector('.no-data-message')) {
            parent.appendChild(createNoDataNotice());
          }
        }
        if (ChartStore.has(id)) {
          ChartStore.get(id).destroy();
          ChartStore.delete(id);
        }
        return null;
      }
      if (typeof Chart === 'undefined') {
        if (!renderChart.chartWarningShown) {
          logEvent('Chart.js not available. Charts will be replaced with notices.');
          renderChart.chartWarningShown = true;
        }
        if (parent) {
          canvas.style.display = 'none';
          if (!parent.querySelector('.no-data-message')) {
            parent.appendChild(createNoDataNotice('Charting library unavailable.')); 
          }
        }
        return null;
      }
      canvas.style.display = '';
      if (parent) {
        const message = parent.querySelector('.no-data-message');
        if (message) parent.removeChild(message);
      }
      if (ChartStore.has(id)) {
        ChartStore.get(id).destroy();
      }
      const chart = new Chart(canvas, config);
      ChartStore.set(id, chart);
      return chart;
    }

    function formatPercent(value, decimals = 1) {
      return `${(value * 100).toFixed(decimals)}%`;
    }

    function buildDashboard1(container, metrics) {
      const grid = document.createElement('div');
      grid.className = 'grid cols-4';
      const env = metrics.environment;
      grid.appendChild(createMetricTile('vCenters', env.vCenters));
      grid.appendChild(createMetricTile('Datacenters', env.datacenters));
      grid.appendChild(createMetricTile('Clusters', env.clusters));
      grid.appendChild(createMetricTile('Hosts', env.hosts));
      grid.appendChild(createMetricTile('Resource Pools', env.resourcePools));
      grid.appendChild(createMetricTile('Virtual Machines', env.vms));
      grid.appendChild(createMetricTile('Standard Switches', env.stdSwitches));
      grid.appendChild(createMetricTile('Distributed Switches', env.dvSwitches));
      grid.appendChild(createMetricTile('Datastores', env.datastores));
      container.appendChild(grid);
    }

    function buildDashboard2(container, metrics) {
      const chartId = 'cluster-overcommit-chart';
      container.appendChild(createChartContainer(chartId, 'radar'));
      const labels = metrics.clusters.clusterStats.map(cluster => cluster.name);
      const cpuData = metrics.clusters.clusterStats.map(cluster => Number(cluster.cpuOvercommit.toFixed(2)));
      const memData = metrics.clusters.clusterStats.map(cluster => Number(cluster.memOvercommit.toFixed(2)));
      renderChart(chartId, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'CPU Overcommit (vCPU : core)',
              data: cpuData,
              backgroundColor: BRAND_COLORS.teal,
              borderColor: BRAND_COLORS.teal
            },
            {
              label: 'Memory Overcommit (Allocated : Physical)',
              data: memData,
              backgroundColor: BRAND_COLORS.red,
              borderColor: BRAND_COLORS.red
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: AXIS_LABEL_COLOR } },
            tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.raw}` } }
          },
          scales: {
            x: { ticks: { color: AXIS_LABEL_COLOR }, grid: { color: GRID_COLOR } },
            y: {
              ticks: { color: AXIS_LABEL_COLOR },
              grid: { color: GRID_COLOR },
              beginAtZero: true
            }
          }
        }
      });
    }

    function buildDashboard3(container, metrics) {
      const headers = ['Cluster', 'CPU Overcommit', 'Memory Overcommit', 'Total vCPU', 'Total Allocated Memory (GB)', 'Hosts'];
      const rows = metrics.clusters.clusterStats.map(cluster => [
        cluster.name,
        (cluster.cpuOvercommit || 0).toFixed(2),
        (cluster.memOvercommit || 0).toFixed(2),
        cluster.totalVcpus,
        (cluster.totalMemAlloc / 1024).toFixed(1),
        cluster.hostCount
      ]);
      container.appendChild(createTable(headers, rows));

      const recos = [];
      if (metrics.clusters.highCpu.length) {
        const list = metrics.clusters.highCpu.map(c => `${c.name} (${c.cpuOvercommit.toFixed(2)}x)`);
        recos.push(`Reduce CPU contention in ${list.join(', ')} by right-sizing oversized VMs or redistributing workloads.`);
      } else {
        recos.push('CPU overcommit ratios are within the healthy range (<4:1) across all clusters. Maintain proactive capacity checks.');
      }
      if (metrics.clusters.highMem.length) {
        const list = metrics.clusters.highMem.map(c => `${c.name} (${c.memOvercommit.toFixed(2)}x)`);
        recos.push(`Review memory allocation in ${list.join(', ')}. Target <=1:1 committed:physical ratio to avoid ballooning or swap usage.`);
      } else {
        recos.push('Memory allocation aligns with physical capacity. Continue to track application growth and reservations.');
      }
      recos.push('Enable automated reclamation via vRealize Operations or ARIA Ops rightsizing reports to sustain balance.');
      container.appendChild(createRecommendationList(recos));
    }

    function buildDashboard4(container, metrics) {
      const chartIdVc = 'vcenter-version-chart';
      const chartIdEsx = 'esx-version-chart';
      const regroup = document.createElement('div');
      regroup.className = 'two-column';
      regroup.appendChild(createChartContainer(chartIdVc));
      regroup.appendChild(createChartContainer(chartIdEsx));
      container.appendChild(regroup);

      renderChart(chartIdVc, {
        type: 'pie',
        data: {
          labels: metrics.versions.vCenters.map(v => v.version),
          datasets: [{
            data: metrics.versions.vCenters.map(v => v.count),
            backgroundColor: generatePalette(metrics.versions.vCenters.length)
          }]
        },
        options: {
          plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } }
        }
      });

      renderChart(chartIdEsx, {
        type: 'pie',
        data: {
          labels: metrics.versions.esxi.map(v => v.version),
          datasets: [{
            data: metrics.versions.esxi.map(v => v.count),
            backgroundColor: generatePalette(metrics.versions.esxi.length, 'teal')
          }]
        },
        options: {
          plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } }
        }
      });
    }

    function generatePalette(count, tone = 'primary') {
      const palettes = {
        primary: ['#00a9e0', '#c8102e', '#fdb913', '#005587', '#a7a8aa'],
        blue: ['#00a9e0', '#c8102e', '#fdb913', '#005587', '#a7a8aa'],
        teal: ['#00a9e0', '#71c5e8', '#48a9c5', '#0b6fa4', '#005587', '#a7a8aa']
      };
      const base = palettes[tone] || palettes.primary;
      const palette = [];
      for (let i = 0; i < count; i++) {
        palette.push(base[i % base.length]);
      }
      return palette;
    }

    function buildDashboard5(container, metrics) {
      const headers = ['Component', 'Version', 'Build', 'Count', 'Lifecycle'];
      const rows = [];
      metrics.versions.vCenters.forEach(v => {
        const lifecycle = computeLifecycleState(v.major, EOS_CALENDAR.vcenter);
        rows.push([
          'vCenter',
          v.version,
          v.build || '—',
          v.count,
          lifecycleBadge(lifecycle)
        ]);
      });
      metrics.versions.esxi.forEach(v => {
        const lifecycle = computeLifecycleState(v.major, EOS_CALENDAR.esxi);
        rows.push([
          'ESXi',
          v.version,
          v.build || '—',
          v.count,
          lifecycleBadge(lifecycle)
        ]);
      });
      container.appendChild(createTable(headers, rows));

      const recos = [];
      const expired = rows.filter(row => row[4].classList?.contains('heat-red'));
      const expiring = rows.filter(row => row[4].classList?.contains('heat-amber'));
      if (expired.length) recos.push('Plan immediate upgrades for components already out of support to restore vendor coverage.');
      if (expiring.length) recos.push('Schedule upgrades within the next quarter for builds approaching end of support to secure patch access.');
      recos.push('Standardize on a single major release per site to simplify lifecycle management and rollback procedures.');
      container.appendChild(createRecommendationList(recos));
    }

    function lifecycleBadge(lifecycle) {
      const span = document.createElement('span');
      span.className = 'heat-cell ' + (lifecycle.state === 'expired' ? 'heat-red' : lifecycle.state === 'expiring' ? 'heat-amber' : lifecycle.state === 'healthy' ? 'heat-green' : '');
      span.textContent = lifecycle.state === 'expired' ? 'End of Support' : lifecycle.state === 'expiring' ? 'Expiring < 6 months' : lifecycle.state === 'healthy' ? 'Supported' : 'Unknown';
      if (lifecycle.eosDate) {
        span.textContent += ` (EOS ${lifecycle.eosDate.toISOString().slice(0, 10)})`;
      }
      return span;
    }

    function buildDashboard6(container, metrics) {
      const chartId = 'datastore-free-chart';
      container.appendChild(createChartContainer(chartId, null, 'chart-wrapper--wide'));
      const labels = metrics.datastores.datastores.map(ds => ds.name);
      const data = metrics.datastores.datastores.map(ds => Number(ds.freePct.toFixed(1)));
      renderChart(chartId, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Free Space (%)',
            data,
            backgroundColor: BRAND_COLORS.teal,
            borderColor: BRAND_COLORS.teal
          }]
        },
        options: {
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: AXIS_LABEL_COLOR } },
            y: { ticks: { color: AXIS_LABEL_COLOR }, beginAtZero: true, max: 100 }
          }
        }
      });
    }

    function buildDashboard7(container, metrics) {
      const headers = ['Datastore', 'Capacity (TiB)', 'Used (TiB)', 'Free (TiB)', 'Free %'];
      const topDatastores = metrics.datastores.datastores.slice(0, 10);
      if (!topDatastores.length) {
        container.appendChild(createNoDataNotice('No datastore records available.'));
        return;
      }
      const rows = topDatastores.map(ds => [
        ds.name,
        ds.capacityTB.toFixed(2),
        ds.usedTB.toFixed(2),
        ds.freeTB.toFixed(2),
        `${ds.freePct.toFixed(1)}%`
      ]);
      container.appendChild(createTable(headers, rows));

      const recos = [];
      if (metrics.datastores.lowFree.length) {
        const list = metrics.datastores.lowFree.map(ds => `${ds.name} (${ds.freePct.toFixed(1)}%)`);
        recos.push(`Prioritize expansion or reclamation on ${list.join(', ')} to maintain >20% free capacity.`);
      } else {
        recos.push('Datastore free space exceeds 20% everywhere. Maintain snapshot hygiene and thin provisioning controls.');
      }
      recos.push('Enable storage policy-based management (SPBM) tagging to align workloads with performance tiers.');
      recos.push('Automate datastore balancing via Storage DRS or vSAN rebalancing to prevent sudden hotspots.');
      container.appendChild(createRecommendationList(recos));
    }

    function buildDashboard8(container, metrics) {
      const chartAge = 'snapshot-age-chart';
      const chartSize = 'snapshot-size-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartAge));
      wrap.appendChild(createChartContainer(chartSize));
      container.appendChild(wrap);

      const ageLabels = Array.from(metrics.snapshots.categories.age.keys());
      renderChart(chartAge, {
        type: 'pie',
        data: {
          labels: ageLabels,
          datasets: [{
            data: ageLabels.map(label => metrics.snapshots.categories.age.get(label)),
            backgroundColor: generatePalette(ageLabels.length)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });

      const sizeLabels = Array.from(metrics.snapshots.categories.size.keys());
      renderChart(chartSize, {
        type: 'pie',
        data: {
          labels: sizeLabels,
          datasets: [{
            data: sizeLabels.map(label => metrics.snapshots.categories.size.get(label)),
            backgroundColor: generatePalette(sizeLabels.length, 'teal')
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard9(container, metrics) {
      const headers = ['VM', 'Snapshot Name', 'Age (days)', 'Size (GiB)', 'Datastore'];
      const riskiest = metrics.snapshots.highestRiskSnapshots || [];
      if (!riskiest.length) {
        container.appendChild(createNoDataNotice('No snapshots with elevated age or size detected.'));
        return;
      }
      const rows = riskiest.map(snap => [
        snap.vm,
        snap.name,
        snap.ageDays ?? diffInDays(snap.createdAt, new Date()),
        snap.sizeGiB ?? (snap.sizeMiB / 1024).toFixed(2),
        snap.datastore || 'n/a'
      ]);
      container.appendChild(createTable(headers, rows));

      const recos = [
        'Remove or consolidate snapshots older than 30 days to prevent delta growth and performance degradation.',
        'Align snapshot retention with backup policy; rely on image-level backups instead of long-running deltas.',
        'Implement automated alerts for snapshots exceeding 15 GiB or 14 days to keep storage predictable.'
      ];
      container.appendChild(createRecommendationList(recos));
    }

    function buildDashboard10(container, metrics) {
      const chartId = 'consolidation-chart';
      container.appendChild(createChartContainer(chartId, 'radar'));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: ['Consolidation Needed', 'No Consolidation'],
          datasets: [{
            data: [metrics.consolidation.counts.true, metrics.consolidation.counts.false],
            backgroundColor: [BRAND_COLORS.red, BRAND_COLORS.teal]
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard11(container, metrics) {
      const recos = [];
      if (metrics.consolidation.requiringConsolidation.length) {
        const names = metrics.consolidation.requiringConsolidation.slice(0, 5).map(vm => vm.name).join(', ');
        recos.push(`Trigger snapshot consolidation for: ${names}.`);
      }
      recos.push('Integrate consolidation checks into nightly operational runbooks or vROps alerts.');
      recos.push('Verify no backup agents hold snapshots open before manual deletion to avoid data loss.');
      recos.push('Automate consolidation with PowerCLI post-backup scripts to close deltas immediately.');
      container.appendChild(createRecommendationList(recos));
    }

    function buildDashboard12(container, metrics) {
      const chartId = 'large-vm-cluster-chart';
      container.appendChild(createChartContainer(chartId, 'radar'));
      renderChart(chartId, {
        type: 'bar',
        data: {
          labels: metrics.largeVMs.perCluster.map(item => item.cluster),
          datasets: [{
            label: 'Large VM Count',
            data: metrics.largeVMs.perCluster.map(item => item.count),
            backgroundColor: BRAND_COLORS.blue
          }]
        },
        options: {
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: AXIS_LABEL_COLOR } },
            y: { ticks: { color: AXIS_LABEL_COLOR }, beginAtZero: true }
          }
        }
      });
    }

    function buildDashboard13(container, metrics) {
      const headers = ['VM', 'Cluster', 'vCPU', 'Memory (GB)', 'Disk (TB)'];
      const rows = metrics.largeVMs.topLarge.map(vm => [vm.name, vm.cluster, vm.cpus, vm.memoryGB, vm.diskTB]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Review reservations and shares for large VMs to avoid starving smaller workloads.',
        'Validate large VMs align with NUMA boundaries; consider CPU socket affinity if required.',
        'Explore scale-out patterns (clustering, load balancers) before scaling up further.'
      ]));
    }

    function buildDashboard14(container, metrics) {
      const chartId = 'powerstate-chart';
      container.appendChild(createChartContainer(chartId));
      const labels = Object.keys(metrics.powerStates.counts);
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels,
          datasets: [{
            data: labels.map(label => metrics.powerStates.counts[label]),
            backgroundColor: generatePalette(labels.length, 'teal')
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard15(container, metrics) {
      const headers = ['VM', 'vCPU', 'Memory (GB)', 'Disk (TB)'];
      const rows = metrics.powerStates.poweredOff.map(vm => [vm.name, vm.cpus, vm.memoryGB, vm.diskTB]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Decommission or archive powered-off VMs older than 30 days to reclaim compute and storage.',
        'Audit change records for powered-off production workloads; ensure tickets exist before powering on.',
        'Tag retained powered-off VMs with purpose (e.g., rollback, quarantine) for transparency.'
      ]));
    }

    function buildDashboard16(container, metrics) {
      const headers = ['VM', 'Cluster', 'Host', 'Power-On Date', 'Days Online'];
      const rows = metrics.uptime.poweredOn.map(vm => [
        vm.name,
        vm.cluster,
        vm.host,
        vm.powerOnDate ? vm.powerOnDate.toISOString().slice(0, 10) : 'Unknown',
        vm.days
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Coordinate maintenance windows for long-running VMs to clear driver memory leaks and apply patches.',
        'Use rolling reboot waves to maintain cluster resiliency and reduce unplanned downtime.',
        'Validate application owners support planned reboots; align with change management calendars.'
      ]));
    }

    function buildDashboard17(container, metrics) {
      const chartHa = 'ha-status-chart';
      const chartDrs = 'drs-status-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartHa));
      wrap.appendChild(createChartContainer(chartDrs));
      container.appendChild(wrap);
      renderChart(chartHa, {
        type: 'pie',
        data: {
          labels: Object.keys(metrics.haDrs.haCounts),
          datasets: [{ data: Object.values(metrics.haDrs.haCounts), backgroundColor: generatePalette(2) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      renderChart(chartDrs, {
        type: 'pie',
        data: {
          labels: Object.keys(metrics.haDrs.drsCounts),
          datasets: [{ data: Object.values(metrics.haDrs.drsCounts), backgroundColor: generatePalette(2, 'teal') }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard18(container, metrics) {
      const headers = ['Cluster', 'HA', 'DRS', 'Admission Control'];
      const rows = metrics.haDrs.clusters.map(cluster => [
        cluster.name,
        badge(cluster.haEnabled ? 'Enabled' : 'Disabled', cluster.haEnabled ? 'pill-green' : 'pill-red'),
        badge(cluster.drsEnabled ? 'Enabled' : 'Disabled', cluster.drsEnabled ? 'pill-green' : 'pill-red'),
        badge(cluster.admissionControlEnabled ? 'Enabled' : 'Disabled', cluster.admissionControlEnabled ? 'pill-green' : 'pill-amber')
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Ensure HA is enabled on all production clusters to maintain automated failover coverage.',
        'Run the DRS cluster configuration check to transition manual clusters to semi or fully automated modes.',
        'Document admission control policies and align with SLA requirements for N+1 capacity.'
      ]));
    }

    function badge(text, className) {
      const span = document.createElement('span');
      span.className = `status-pill ${className}`;
      span.textContent = text;
      return span;
    }

    function buildDashboard19(container, metrics) {
      const chartId = 'cd-connection-chart';
      container.appendChild(createChartContainer(chartId));
      const labels = ['Connected', 'Disconnected'];
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels,
          datasets: [{
            data: [metrics.media.counts.connected, metrics.media.counts.disconnected],
            backgroundColor: labels.map(label => label === 'Connected' ? BRAND_COLORS.teal : BRAND_COLORS.red)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard20(container, metrics) {
      const headers = ['VM', 'Cluster', 'Devices'];
      const rows = metrics.media.samples.map(vm => [vm.name, vm.cluster, vm.devices]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Disconnect ISO mounts post-installation to prevent host lock or failed vMotion events.',
        'Review SRM-protected VMs for dangling media; mandatory cleanup before DR testing.',
        'Implement policy-based enforcement via vSphere Tags or PowerCLI hygiene scripts.'
      ]));
    }

    function buildDashboard21(container, metrics) {
      const chartStatus = 'vmtools-status-chart';
      const chartVersion = 'vmtools-version-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartStatus));
      wrap.appendChild(createChartContainer(chartVersion));
      container.appendChild(wrap);

      const statuses = Object.keys(metrics.vmTools.statusCounts);
      renderChart(chartStatus, {
        type: 'pie',
        data: {
          labels: statuses,
          datasets: [{ data: statuses.map(key => metrics.vmTools.statusCounts[key]), backgroundColor: generatePalette(statuses.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });

      const versionLabels = metrics.vmTools.topVersions.map(item => item.version);
      renderChart(chartVersion, {
        type: 'pie',
        data: {
          labels: versionLabels,
          datasets: [{ data: metrics.vmTools.topVersions.map(item => item.count), backgroundColor: generatePalette(versionLabels.length, 'teal') }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard22(container, metrics) {
      const headers = ['VMware Tools Version', 'VM Count', 'Lifecycle'];
      const rows = metrics.vmTools.topVersions.map(item => [
        item.version,
        item.count,
        lifecycleBadge(item.eosState)
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Standardize on the latest VMware Tools release to unlock OS customization and quiesced snapshots.',
        'Stage Tools upgrades via vSphere lifecycle manager baselines or guest OS management tools.',
        'Sequence Tools upgrades before ESXi updates to avoid driver mismatches.'
      ]));
    }

    function buildDashboard23(container, metrics) {
      const chartProm = 'pg-promiscuous-chart';
      const chartMac = 'pg-mac-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartProm));
      wrap.appendChild(createChartContainer(chartMac));
      container.appendChild(wrap);

      const promLabels = Object.keys(metrics.networkSecurity.promCounts);
      renderChart(chartProm, {
        type: 'pie',
        data: {
          labels: promLabels,
          datasets: [{
            data: Object.values(metrics.networkSecurity.promCounts),
            backgroundColor: promLabels.map(label => /enabled/i.test(label) ? BRAND_COLORS.red : BRAND_COLORS.teal)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });

      const macLabels = Object.keys(metrics.networkSecurity.macCounts);
      renderChart(chartMac, {
        type: 'pie',
        data: {
          labels: macLabels,
          datasets: [{
            data: Object.values(metrics.networkSecurity.macCounts),
            backgroundColor: macLabels.map(label => /accept|forged/i.test(label) ? BRAND_COLORS.red : BRAND_COLORS.teal)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard24(container, metrics) {
      const headers = ['Port Group', 'Switch', 'VLAN', 'Promiscuous Mode', 'MAC Changes'];
      const rows = metrics.networkSecurity.permissive.map(pg => [
        pg.portGroup,
        pg.switchName,
        pg.vlan,
        pg.promiscuous,
        pg.macChanges
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Restrict promiscuous mode to monitoring port groups with documented approvals.',
        'Enforce MAC change security to prevent spoofing attacks in tenant networks.',
        'Leverage vSphere distributed switch port-level overrides sparingly; prefer port groups.'
      ]));
    }

    function buildDashboard25(container, metrics) {
      const chartId = 'vm-hw-version-chart';
      container.appendChild(createChartContainer(chartId));
      const hwLevels = Array.from(metrics.hardware.vmHardware.entries());
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: hwLevels.map(([version]) => `HW ${version}`),
          datasets: [{ data: hwLevels.map(([, data]) => data.count), backgroundColor: generatePalette(hwLevels.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard26(container, metrics) {
      const headers = ['Hardware Version', 'VM Count', 'Lifecycle'];
      const rows = Array.from(metrics.hardware.vmHardware.entries()).sort((a, b) => Number(a[0]) - Number(b[0])).slice(0, 10).map(([version, data]) => [
        version,
        data.count,
        lifecycleBadge(data.state)
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Upgrade virtual hardware to match target ESXi release before enabling new CPU features.',
        'Coordinate hardware version upgrades with VMware Tools to maintain driver compatibility.',
        'Snapshot VMs prior to hardware upgrades and test rollback on non-production workloads first.'
      ]));
    }

    function buildDashboard27(container, metrics) {
      const headers = ['Template Name', 'Datastore', 'Cluster'];
      const rows = metrics.templates.templates.map(template => [template.name, template.datastore, template.cluster || 'n/a']);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Periodically power on templates to apply guest patching and regenerate Windows SUS IDs.',
        'Store golden images on high-availability datastores with replication to DR sites.',
        'Tag templates with owner and creation date metadata for lifecycle governance.'
      ]));
    }

    function buildDashboard28(container, metrics) {
      const chartId = 'latency-sensitivity-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: Object.keys(metrics.latency.sensitivityCounts),
          datasets: [{
            data: Object.values(metrics.latency.sensitivityCounts),
            backgroundColor: generatePalette(Object.keys(metrics.latency.sensitivityCounts).length)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Validate high latency-sensitivity VMs reside on hosts with consistent CPU models to avoid EVC falls.',
        'Avoid co-locating latency-sensitive workloads with noisy neighbors; enforce resource pools.',
        'Document application owners for high-sensitivity VMs to expedite incident handling.'
      ]));
    }

    function buildDashboard29(container, metrics) {
      const chartId = 'srm-protection-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: ['Protected', 'Not Protected'],
          datasets: [{ data: [metrics.srm.counts.protected, metrics.srm.counts.unprotected], backgroundColor: [BRAND_COLORS.teal, BRAND_COLORS.red] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard30(container, metrics) {
      const headers = ['VM', 'Cluster', 'Host', 'Datastore', 'Port Group'];
      const rows = metrics.srm.samples.map(item => [item.name, item.cluster, item.host, item.datastore, item.network]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Expand SRM protection to tier-1 systems; consider vSphere Replication where array-based replication is absent.',
        'Validate plan compliance quarterly by running non-disruptive test recoveries.',
        'Tag business applications with SRM recovery plans for audit traceability.'
      ]));
    }

    function buildDashboard31(container, metrics) {
      const chartId = 'dns-status-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: ['DNS Known', 'DNS Unknown'],
          datasets: [{ data: [metrics.dns.counts.known, metrics.dns.counts.unknown], backgroundColor: [BRAND_COLORS.teal, BRAND_COLORS.red] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard32(container, metrics) {
      const headers = ['VM', 'Cluster', 'Host'];
      const rows = metrics.dns.unknown.map(item => [item.name, item.cluster, item.host]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Update DNS records for VMs missing entries to enable certificate validation and monitoring.',
        'Integrate CMDB synchronization to prevent drift between DNS and vCenter inventory.',
        'Consider DHCP reservations with option 81 updates to automate reverse lookups.'
      ]));
    }

    function buildDashboard33(container, metrics) {
      const chartId = 'connection-state-chart';
      container.appendChild(createChartContainer(chartId));
      const labels = Object.keys(metrics.connection.counts);
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels,
          datasets: [{ data: labels.map(label => metrics.connection.counts[label]), backgroundColor: generatePalette(labels.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard34(container, metrics) {
      const headers = ['VM', 'Cluster', 'State'];
      const rows = metrics.connection.problematic.map(item => [item.name, item.cluster, item.state]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Clean up orphaned entries by removing stale VMs from inventory.',
        'Investigate disconnected VMs for host issues or removed network uplinks.',
        'Tie vCenter alarms to ticketing for inaccessible states to shorten MTTR.'
      ]));
    }

    function buildDashboard35(container, metrics) {
      const chartId = 'os-alignment-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: ['Aligned', 'Not Aligned'],
          datasets: [{ data: [metrics.osDrift.align, metrics.osDrift.drift], backgroundColor: [BRAND_COLORS.teal, BRAND_COLORS.red] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard36(container, metrics) {
      const headers = ['VM', 'Cluster', 'Config File OS', 'VMware Tools OS'];
      const rows = metrics.osDrift.samples.map(item => [item.name, item.cluster, item.osConfig, item.osTools]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Align configured OS type with installed OS to guarantee correct drivers and Tools packages.',
        'Review template deployment process to ensure OS selections match actual media.',
        'Correct OS identifiers before enabling features like Fault Tolerance or vGPU.'
      ]));
    }

    function buildDashboard37(container, metrics) {
      const chartId = 'nic-connection-chart';
      container.appendChild(createChartContainer(chartId));
      const nicLabels = ['Connected adapters', 'Disconnected adapters'];
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: nicLabels,
          datasets: [{
            data: [metrics.nic.nicStates.connected, metrics.nic.nicStates.disconnected],
            backgroundColor: nicLabels.map(label => label.includes('Disconnected') ? BRAND_COLORS.red : BRAND_COLORS.teal)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard38(container, metrics) {
      const headers = ['VM', 'Cluster', '# Adapters'];
      const rows = metrics.nic.disconnectedVMs.map(vm => [vm.name, vm.cluster, vm.adapters]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Remove unused network adapters to reduce security exposure.',
        'Validate VLAN membership for intentionally disconnected interfaces and document rationale.',
        'Automate NIC state checks via vROps to detect mass disconnect events.'
      ]));
    }

    function buildDashboard39(container, metrics) {
      const headers = ['VM', 'Adapters', 'Cluster'];
      const rows = metrics.nic.multiNic.map(vm => [vm.name, vm.adapters, vm.cluster]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Use consistent network adapter counts across app tiers to simplify troubleshooting.',
        'Document multi-NIC designs (e.g., backup, heartbeat) to avoid accidental removal.',
        'Review load balancing or multi-path policies for VMs consuming redundant uplinks.'
      ]));
    }

    function buildDashboard40(container, metrics) {
      const chartId = 'backup-status-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: ['Protected', 'Not Protected'],
          datasets: [{ data: [metrics.backups.counts.protected, metrics.backups.counts.unprotected], backgroundColor: [BRAND_COLORS.teal, BRAND_COLORS.red] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Integrate backup reporting with vCenter tags to flag unprotected VMs automatically.',
        'Validate backup job success daily and reconcile against CMDB-critical application lists.',
        'Implement immutable backup storage to protect against ransomware-driven deletion.'
      ]));
    }

    function buildDashboard41(container, metrics) {
      const chartId = 'evc-mode-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: Object.keys(metrics.evc.counts),
          datasets: [{ data: Object.values(metrics.evc.counts), backgroundColor: generatePalette(Object.keys(metrics.evc.counts).length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard42(container, metrics) {
      const headers = ['EVC Mode', 'Host Count'];
      const rows = metrics.evc.summary.map(item => [item.evc, item.count]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Align EVC baselines across clusters to simplify cross-cluster vMotion.',
        'Upgrade CPU microcode and firmware prior to raising EVC levels.',
        'Maintain documentation on EVC dependencies for hybrid or workload mobility plans.'
      ]));
    }

    function buildDashboard43(container, metrics) {
      const headers = ['Cluster', 'vMotions'];
      const targets = metrics.vmotion.topClusters || metrics.vmotion.clusters || [];
      if (!targets.length) {
        container.appendChild(createNoDataNotice('No vMotion activity recorded.'));
        return;
      }
      const rows = targets.map(item => [item.name, item.vmotions]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Investigate clusters with low vMotion counts to ensure DRS automation is functioning.',
        'High vMotion rates may indicate contention; monitor workload placement decisions closely.',
        'Enable vMotion logging for troubleshooting and audit traceability.'
      ]));
    }

    function buildDashboard44(container, metrics) {
      const chartId = 'admission-control-chart';
      container.appendChild(createChartContainer(chartId));
      const admLabels = Object.keys(metrics.admission.counts);
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: admLabels,
          datasets: [{
            data: Object.values(metrics.admission.counts),
            backgroundColor: admLabels.map(label => /enabled/i.test(label) ? BRAND_COLORS.teal : BRAND_COLORS.red)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard45(container, metrics) {
      const headers = ['Cluster', 'Admission Control'];
      const rows = metrics.admission.clusters.map(cluster => [cluster.name, cluster.admissionControlEnabled ? 'Enabled' : 'Disabled']);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Enable admission control to protect failover capacity for critical workloads.',
        'Select a policy (slot, percentage, or dedicated failover hosts) aligned with SLA commitments.',
        'Review policy settings quarterly as cluster size or workload mix changes.'
      ]));
    }

    function buildDashboard46(container, metrics) {
      const chartCpu = 'cpu-reservation-chart';
      const chartMem = 'mem-reservation-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartCpu));
      wrap.appendChild(createChartContainer(chartMem));
      container.appendChild(wrap);
      renderChart(chartCpu, {
        type: 'pie',
        data: {
          labels: ['Reservation Set', 'No Reservation'],
          datasets: [{ data: [metrics.reservations.counts.cpu.yes, metrics.reservations.counts.cpu.no], backgroundColor: [BRAND_COLORS.gold, BRAND_COLORS.gray] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      renderChart(chartMem, {
        type: 'pie',
        data: {
          labels: ['Reservation Set', 'No Reservation'],
          datasets: [{ data: [metrics.reservations.counts.memory.yes, metrics.reservations.counts.memory.no], backgroundColor: [BRAND_COLORS.gold, BRAND_COLORS.gray] }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Reserve CPU/memory only when required by licensing or low-latency apps to preserve cluster flexibility.',
        'Document business justification for reservations and review alignment annually.',
        'Consider resource pools with shares instead of reservations to balance priorities dynamically.'
      ]));
    }

    function buildDashboard47(container, metrics) {
      const chartCpu = 'cpu-hotadd-chart';
      const chartMem = 'mem-hotadd-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartCpu));
      wrap.appendChild(createChartContainer(chartMem));
      container.appendChild(wrap);
      const hotCpuLabels = ['CPU Hot Add Enabled', 'Disabled'];
      renderChart(chartCpu, {
        type: 'pie',
        data: {
          labels: hotCpuLabels,
          datasets: [{
            data: [metrics.hotAdd.counts.cpu.yes, metrics.hotAdd.counts.cpu.no],
            backgroundColor: hotCpuLabels.map(label => label.includes('Enabled') ? BRAND_COLORS.teal : BRAND_COLORS.gray)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      const hotMemLabels = ['Memory Hot Add Enabled', 'Disabled'];
      renderChart(chartMem, {
        type: 'pie',
        data: {
          labels: hotMemLabels,
          datasets: [{
            data: [metrics.hotAdd.counts.memory.yes, metrics.hotAdd.counts.memory.no],
            backgroundColor: hotMemLabels.map(label => label.includes('Enabled') ? BRAND_COLORS.teal : BRAND_COLORS.gray)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Enable hot-add selectively; it can disable vNUMA optimizations on some OSes.',
        'Coordinate with application owners to schedule scaling windows if hot-add is disabled.',
        'Ensure backup software supports hot-add states to avoid snapshot failures.'
      ]));
    }

    function buildDashboard48(container, metrics) {
      const headers = ['VM', 'Cluster', 'Disk Label', 'Disk Size (TB)', 'Datastore'];
      const rows = metrics.disks.largestDisks.map(disk => [disk.vm, disk.cluster, disk.label, disk.sizeTB, disk.datastore || 'n/a']);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Validate backup windows for large disks; consider CBT or array-based replication for efficiency.',
        'Review storage policy compliance; large disks may require dedicated datastores.',
        'Align large disk growth with thin provisioning and monitoring to avoid sudden datastore exhaustion.'
      ]));
    }

    function buildDashboard49(container, metrics) {
      const chartId = 'vendor-distribution-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: metrics.vendors.vendorCounts.map(([vendor]) => vendor),
          datasets: [{ data: metrics.vendors.vendorCounts.map(([, count]) => count), backgroundColor: generatePalette(metrics.vendors.vendorCounts.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard50(container, metrics) {
      const headers = ['Vendor', 'Model', 'Host Count'];
      const rows = metrics.vendors.vendorModelCounts.map(item => [item.vendor, item.model, item.count]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Standardize host models per cluster to simplify firmware management and sparing.',
        'Engage OEM support to confirm BIOS/firmware alignment with VMware Hardware Compatibility List.',
        'Map hardware refresh cadence to application criticality and depreciation schedules.'
      ]));
    }

    function buildDashboard51(container, metrics) {
      const chartId = 'cpu-model-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: metrics.cpuModels.cpuCounts.map(([model]) => model),
          datasets: [{ data: metrics.cpuModels.cpuCounts.map(([, count]) => count), backgroundColor: generatePalette(metrics.cpuModels.cpuCounts.length, 'teal') }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard52(container, metrics) {
      const headers = ['CPU Model', 'Host Count', 'Total Cores', 'Avg Cores/Host'];
      const summaries = metrics.cpuModels.modelSummaries || [];
      if (!summaries.length) {
        container.appendChild(createNoDataNotice('No CPU model data discovered.'));
        return;
      }
      const rows = summaries.map(item => [
        item.model,
        item.hostCount,
        item.totalCores,
        item.avgCoresPerHost ? item.avgCoresPerHost.toFixed(1) : '0.0'
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        `Total cores across environment: ${metrics.cpuModels.totalCores}. Use this baseline for capacity planning and licensing.`,
        'Monitor core count per host when introducing new CPU models to maintain EVC compatibility.',
        'Right-size cluster sizes to balance total cores per fault domain.'
      ]));
    }

    function buildDashboard53(container, metrics) {
      const headers = ['Policy', 'Count'];
      const rows = metrics.teaming.policies.map(([policy, count]) => [policy, count]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Use load-based teaming on distributed switches for dynamic traffic distribution.',
        'Document failover order for uplinks and test during maintenance windows.',
        'Align teaming strategies with physical network design and upstream LACP policies.'
      ]));
    }

    function buildDashboard54(container, metrics) {
      const chartId = 'vlan-distribution-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: metrics.vlan.vlanCounts.map(([vlan]) => `VLAN ${vlan}`),
          datasets: [{ data: metrics.vlan.vlanCounts.map(([, count]) => count), backgroundColor: generatePalette(metrics.vlan.vlanCounts.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard55(container, metrics) {
      const headers = ['VLAN', 'Connected VMs'];
      const rows = metrics.vlan.topVLANs.map(([vlan, count]) => [vlan, count]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Baseline VLAN utilization to plan for network segmentation or NSX migrations.',
        'Ensure firewall rules cover high-density VLANs to mitigate blast radius.',
        'Tag VLANs with business owner metadata for faster incident response.'
      ]));
    }

    function buildDashboard56(container, metrics) {
      const chartId = 'vm-per-datastore-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'bar',
        data: {
          labels: metrics.density.datastores.map(item => item.name),
          datasets: [{ label: 'VM Count', data: metrics.density.datastores.map(item => item.vmCount), backgroundColor: BRAND_COLORS.gold }]
        },
        options: { plugins: { legend: { display: false } }, scales: { x: { ticks: { color: AXIS_LABEL_COLOR } }, y: { beginAtZero: true, ticks: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Rebalance hot datastores using Storage vMotion or SDRS to prevent contention.',
        'Align datastore density to array performance tier and replication policies.',
        'Audit datastores exceeding 150 VMs for backup and snapshot impact.'
      ]));
    }

    function buildDashboard57(container, metrics) {
      const chartId = 'vm-per-host-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'bar',
        data: {
          labels: metrics.density.hosts.map(item => item.name),
          datasets: [{ label: 'VM Count', data: metrics.density.hosts.map(item => item.vmCount), backgroundColor: BRAND_COLORS.gold }]
        },
        options: { plugins: { legend: { display: false } }, scales: { x: { ticks: { color: AXIS_LABEL_COLOR } }, y: { beginAtZero: true, ticks: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Balance VM counts across hosts to maintain N+1 compliance.',
        'Investigate hosts with low VM counts for maintenance mode or compatibility constraints.',
        'Leverage DRS affinity rules to control workload placement as density changes.'
      ]));
    }

    function buildDashboard58(container, metrics) {
      const chartId = 'multipath-policy-chart';
      container.appendChild(createChartContainer(chartId));
      renderChart(chartId, {
        type: 'pie',
        data: {
          labels: metrics.multiPath.policies.map(([policy]) => policy),
          datasets: [{ data: metrics.multiPath.policies.map(([, count]) => count), backgroundColor: generatePalette(metrics.multiPath.policies.length) }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      container.appendChild(createRecommendationList([
        'Standardize on Round Robin (VMW_PSP_RR) for active-active arrays wherever supported.',
        'Coordinate multipath policy changes with storage teams and vendor best practices.',
        'Monitor path failover events to confirm policy behavior during fabric incidents.'
      ]));
    }

    function buildDashboard59(container, metrics) {
      const chartDns = 'dns-config-chart';
      const chartNtp = 'ntp-config-chart';
      const wrap = document.createElement('div');
      wrap.className = 'two-column';
      wrap.appendChild(createChartContainer(chartDns));
      wrap.appendChild(createChartContainer(chartNtp));
      container.appendChild(wrap);
      const dnsLabelsHost = Object.keys(metrics.hostServices.dns);
      renderChart(chartDns, {
        type: 'pie',
        data: {
          labels: dnsLabelsHost,
          datasets: [{
            data: Object.values(metrics.hostServices.dns),
            backgroundColor: dnsLabelsHost.map(label => /not|no|missing|unconfigured/i.test(label) ? BRAND_COLORS.red : BRAND_COLORS.teal)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
      const ntpLabelsHost = Object.keys(metrics.hostServices.ntp);
      renderChart(chartNtp, {
        type: 'pie',
        data: {
          labels: ntpLabelsHost,
          datasets: [{
            data: Object.values(metrics.hostServices.ntp),
            backgroundColor: ntpLabelsHost.map(label => /not|no|missing|unconfigured/i.test(label) ? BRAND_COLORS.red : BRAND_COLORS.teal)
          }]
        },
        options: { plugins: { legend: { position: 'bottom', labels: { color: AXIS_LABEL_COLOR } } } }
      });
    }

    function buildDashboard60(container, metrics) {
      const totals = metrics.hostServices.totals;
      if (!totals || !totals.totalHosts) {
        container.appendChild(createNoDataNotice('No ESXi host service records found.'));
        return;
      }

      const summaryHeaders = ['Service', 'Configured', 'Not Configured'];
      const summaryRows = [
        ['DNS', totals.dns.configured, totals.dns.notConfigured],
        ['NTP', totals.ntp.configured, totals.ntp.notConfigured]
      ];
      container.appendChild(createTable(summaryHeaders, summaryRows));

      const headers = ['Host', 'DNS Configured', 'NTP Configured'];
      const rows = metrics.hostServices.gaps.map(host => [
        host.name,
        badge(host.dnsConfigured ? 'Yes' : 'No', host.dnsConfigured ? 'pill-green' : 'pill-red'),
        badge(host.ntpConfigured ? 'Yes' : 'No', host.ntpConfigured ? 'pill-green' : 'pill-red')
      ]);
      container.appendChild(createTable(headers, rows));

      container.appendChild(createRecommendationList([
        'Configure forward and reverse DNS for every ESXi host to avoid certificate mismatches.',
        'Configure two or more NTP servers per host and validate drift alerts in monitoring platforms.',
        'Include DNS/NTP configuration verification in host build automation checklists.'
      ]));
    }

    function buildDashboard61(container, metrics) {
      const chartId = 'assessment-radar-chart';
      container.appendChild(createChartContainer(chartId, 'radar'));
      const scores = computePillarScores(metrics);
      renderChart(chartId, {
        type: 'radar',
        data: {
          labels: Object.keys(scores),
          datasets: [{
            label: 'Readiness Score (0-5)',
            data: Object.values(scores),
            backgroundColor: 'rgba(0, 169, 224, 0.25)',
            borderColor: BRAND_COLORS.teal,
            pointBackgroundColor: BRAND_COLORS.red,
            pointBorderColor: BRAND_COLORS.blue
          }]
        },
        options: {
          scales: {
            r: {
              beginAtZero: true,
              max: 5,
              ticks: { showLabelBackdrop: false, color: AXIS_LABEL_COLOR },
              angleLines: { color: GRID_COLOR },
              grid: { color: GRID_COLOR }
            }
          },
          plugins: { legend: { display: false } }
        }
      });
      const guidance = document.createElement('div');
      guidance.className = 'spider-guidance';
      Object.entries(scores).forEach(([pillar, score]) => {
        guidance.innerHTML += `<span><strong>${pillar}:</strong> ${score.toFixed(1)} / 5</span>`;
      });
      container.appendChild(guidance);
    }

    function computePillarScores(metrics) {
      const scores = {
        Availability: 5,
        Manageability: 5,
        Performance: 5,
        Recoverability: 5,
        Security: 5,
        Cost: 5
      };
      if (metrics.datastores.lowFree.length) scores.Availability -= 1.5;
      if (metrics.consolidation.requiringConsolidation.length) scores.Availability -= 0.5;
      if (metrics.clusters.highCpu.length || metrics.clusters.highMem.length) scores.Performance -= 1.5;
      if (metrics.snapshots.oldestSnapshots.some(s => diffInDays(s.createdAt, new Date()) > 90)) scores.Manageability -= 1;
      if (metrics.backups.counts.unprotected) scores.Recoverability -= 1.5;
      if (metrics.networkSecurity.permissive.length) scores.Security -= 1;
      if (metrics.osDrift.drift) scores.Manageability -= 0.5;
      if (metrics.powerStates.poweredOff.length) scores.Cost -= 1;
      Object.keys(scores).forEach(key => {
        if (scores[key] < 0.5) scores[key] = 0.5;
      });
      return scores;
    }

    function buildDashboard62(container, metrics) {
      const headers = ['Pillar', '30 Days', '60 Days', '90 Days'];
      const rows = buildRemediationPlan(metrics);
      container.appendChild(createTable(headers, rows));
    }

    function buildRemediationPlan(metrics) {
      return [
        ['Availability', 'Clean up aged snapshots and consolidate pending deltas.', 'Expand capacity on datastores <20% free space.', 'Automate datastore rebalancing and monitor failover capacity.'],
        ['Manageability', 'Document powered-off VMs and enforce lifecycle tags.', 'Standardize VMware Tools and hardware versions.', 'Integrate CMDB automation and continuous compliance checks.'],
        ['Performance', 'Right-size VMs with >4:1 CPU overcommit clusters.', 'Balance workloads across hosts based on DRS insights.', 'Deploy performance analytics (ARIA Ops) dashboards for tuning.'],
        ['Recoverability', 'Identify unprotected VMs using backup status insights.', 'Extend SRM coverage to priority applications.', 'Test DR plans and document recovery success metrics.'],
        ['Security', 'Disable promiscuous/mac-change on non-approved port groups.', 'Align OS configuration with guest tools reports.', 'Implement continuous security posture checks for VM media devices.'],
        ['Cost', 'Decommission powered-off and zombie workloads.', 'Review large VM resource allocations vs. actual usage.', 'Implement chargeback/showback leveraging rightsizing outputs.']
      ];
    }

    function buildDashboard63(container, metrics) {
      const messages = metrics.health?.messages || [];
      if (!messages.length) {
        container.appendChild(createNoDataNotice('No vHealth findings were imported.'));
        return;
      }
      const headers = ['Message', 'Occurrences', 'Sample Object', 'Sample Detail'];
      const topMessages = messages.slice(0, 10);
      const rows = topMessages.map(item => [
        item.message,
        item.count,
        item.sampleObject || 'n/a',
        item.sampleDetail || '—'
      ]);
      container.appendChild(createTable(headers, rows));
      container.appendChild(createRecommendationList([
        'Review top recurring health messages weekly and close remediation actions before repeating exports.',
        'Tag accountable owners for each finding to accelerate fixes and update your CMDB.',
        'Incorporate vHealth checks into pre-change validation to prevent regressions in host and VM hygiene.'
      ]));
    }

    function buildDashboard64(container, metrics) {
      if (!state.metrics) {
        container.appendChild(createNoDataNotice('Import RVTools exports before generating reports.'));
        return;
      }
      const insights = collectReportInsights(metrics, state.data);
      const workbookCount = insights.workbookCount || (Array.isArray(state.data?.workbooks) ? state.data.workbooks.length : 0);

      const meta = document.createElement('p');
      meta.className = 'muted';
      meta.textContent = `Latest workbook timestamp: ${formatDateTime(insights.generatedAt)} · Workbooks processed: ${formatNumber(workbookCount)}`;
      container.appendChild(meta);

      const actions = document.createElement('div');
      actions.className = 'export-actions';
      actions.appendChild(createExportButton('Export PDF Report', 'pdf'));
      container.appendChild(actions);

      container.appendChild(createRecommendationList([
        'Attach the generated PDF to executive briefings and change advisory documentation.',
        'Refresh exports whenever new RVTools datasets are imported to keep narratives current.',
        'Annotate the PDF with customer branding or contextual notes before distribution.'
      ]));
    }
  </script>
</body>
</html>
